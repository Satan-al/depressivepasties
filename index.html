<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>DepressivePasties</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="telegram_link_styles.css">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%A5%9F%3C/text%3E%3C/svg%3E">
  <style>
    :root {
      --bg: #0b1216; --fg: #e6edf3; --muted: #9aa4af;
      --accent: #16c7b7; --accent-2: #0ea5a0;
      --panel: #0f1722; --panel2: #0b1420; --border: #1e2633;
      --input-bg: #0b1420; --input-border: #223044;
      --blur: 14px;
    }
    
    
    /* Global scrollbars (bottom scrollers, lists, etc.) */
    *{ scrollbar-width: thin; scrollbar-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45) rgba(30,38,51,0.22); }
    *::-webkit-scrollbar{ width:10px; height:10px; }
    *::-webkit-scrollbar-track{ background:rgba(30,38,51,0.22); border-radius:10px; }
    *::-webkit-scrollbar-thumb{
      background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.50));
      border-radius:10px;
      border:2px solid rgba(10,14,20,0.55);
    }
    *::-webkit-scrollbar-thumb:hover{
      background:linear-gradient(180deg, rgba(0,0,0,0.40), rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.65));
    }

    /* ===== Neon / 3D UI (visual only) ===== */
    :root{
      /* mouse "magnet" position */
      --mx: 50vw;
      --my: 30vh;

      /* accent as rgb (JS syncs) */
      --acc-r: 22;
      --acc-g: 199;
      --acc-b: 183;

      /* tuned intensities */
      --neo-glow: 0.55;
      --neo-glow-strong: 0.80;
      --neo-shadow: rgba(0,0,0,0.55);
    }

    /* One global glow ball that follows the cursor */
    body::before{
      content:"";
      position:fixed;
      inset:-20vmax;
      pointer-events:none;
      z-index:0;
      background:
        radial-gradient(22vmax 22vmax at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b), calc(var(--neo-glow) * 0.70)) 0%,
          rgba(120,80,255, calc(var(--neo-glow) * 0.35)) 22%,
          rgba(255,80,190, calc(var(--neo-glow) * 0.25)) 40%,
          rgba(0,255,240, calc(var(--neo-glow) * 0.18)) 58%,
          rgba(0,0,0,0) 72%);
      filter: blur(20px) saturate(1.35);
      mix-blend-mode: screen;
      opacity: 0.9;
      transform: translate3d(0,0,0);
    }
    /* keep app above the glow */
    body > .app{position:relative; z-index:1;}

    /* Oil-slick gradient that always ends in the user's accent */
    .neo-oil{
      background:
        linear-gradient(135deg,
          rgba(120,80,255,0.35),
          rgba(255,80,190,0.25),
          rgba(0,255,240,0.20),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.35)),
        linear-gradient(180deg,
          rgba(255,255,255,0.10),
          rgba(0,0,0,0.20));
    }

    /* subtle animated sheen */
    @keyframes neo-sheen{
      0%{ transform: translateX(-25%) rotate(8deg); opacity:0.0;}
      25%{opacity:0.35;}
      60%{opacity:0.18;}
      100%{ transform: translateX(125%) rotate(8deg); opacity:0.0;}
    }
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:var(--bg);color:var(--fg);font-family:'Open Sans',system-ui,sans-serif;font-size:15px;line-height:1.6}
    
    /* Кастомный скроллбар */
    ::-webkit-scrollbar{width:8px;height:8px}
    ::-webkit-scrollbar-track{background:rgba(30,38,51,0.3);border-radius:4px}
    ::-webkit-scrollbar-thumb{background:linear-gradient(180deg,rgba(22,199,183,0.4),rgba(14,165,160,0.4));border-radius:4px;transition:background 0.2s}
    ::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,rgba(22,199,183,0.6),rgba(14,165,160,0.6))}
    
    /* Анимация пульсации при клике на эмодзи */
    @keyframes reaction-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    
    @keyframes reaction-bg-flash {
      0% { background-color: rgba(22,199,183,0.1); }
      50% { background-color: rgba(22,199,183,0.4); }
      100% { background-color: rgba(10,20,30,0.78); }
    }
    
    .reaction-clicked {
      animation: reaction-pulse 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55),
                 reaction-bg-flash 0.6s ease-out;
    }
    
    .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}

    header{
      display:flex;gap:12px;flex-wrap:wrap;align-items:center;padding:14px 24px;
      position:sticky;top:0;z-index:100;

      border-bottom:1px solid rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);
      box-shadow:
        0 10px 30px rgba(0,0,0,0.55),
        0 0 40px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.10);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);

      /* base + oil slick */
      background:
        linear-gradient(180deg,rgba(15,23,34,0.92),rgba(11,20,32,0.95));
    }
    header::before{
      content:"";
      position:absolute; inset:-1px;
      pointer-events:none;
      border-radius: 0 0 18px 18px;
      opacity:0.95;
      background:
        radial-gradient(1200px 220px at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.20) 0%,
          rgba(120,80,255,0.12) 35%,
          rgba(255,80,190,0.10) 55%,
          rgba(0,0,0,0) 72%),
        linear-gradient(135deg,
          rgba(120,80,255,0.10),
          rgba(255,80,190,0.08),
          rgba(0,255,240,0.06),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.10));
      filter: blur(0px) saturate(1.25);
      mix-blend-mode: screen;
    }
    header::after{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.00) 40%, rgba(0,0,0,0.25));
      opacity:0.65;
    }
    header > *{position:relative; z-index:1;}

    .brand{
      font-family:'Montserrat',sans-serif;font-weight:900;font-size:1.7em;
      background:
        linear-gradient(135deg,
          rgba(120,80,255,0.85),
          rgba(255,80,190,0.80),
          rgba(0,255,240,0.75),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.95));
      -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;
      filter:drop-shadow(0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.35));
      letter-spacing:.06em;
    }


    .btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;

      padding:10px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);

      color: var(--fg);
      background:
        linear-gradient(180deg,
          rgba(255,255,255,0.10),
          rgba(0,0,0,0.16)),
        linear-gradient(135deg,
          rgba(120,80,255,0.10),
          rgba(255,80,190,0.08),
          rgba(0,255,240,0.06),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.16));

      /* stronger 3D depth */
      box-shadow:
        0 14px 26px rgba(0,0,0,0.62),
        0 3px 0 rgba(255,255,255,0.10) inset,
        0 -10px 18px rgba(0,0,0,0.40) inset,
        0 0 0 1px rgba(255,255,255,0.06) inset,
        0 0 28px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.20);

      transform: translateZ(0);
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }

    /* top sheen — tinted toward account accent */
    .btn::before{
      content:"";
      position:absolute;
      inset:1px 1px auto 1px;
      height:52%;
      border-radius:13px;
      background:
        radial-gradient(120px 60px at 20% 20%,
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.40),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.00) 70%),
        linear-gradient(180deg,
          rgba(255,255,255,0.16),
          rgba(255,255,255,0.00));
      opacity:0.95;
      pointer-events:none;
      mix-blend-mode: screen;
      filter: saturate(1.2);
    }

    /* subtle rim glow */
    .btn::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius:15px;
      background:
        radial-gradient(220px 120px at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.30),
          rgba(0,0,0,0) 70%);
      opacity:0.55;
      pointer-events:none;
      filter: blur(10px);
    }

    .btn:hover{
      transform: translateY(-1px);
      box-shadow:
        0 18px 34px rgba(0,0,0,0.66),
        0 3px 0 rgba(255,255,255,0.12) inset,
        0 -12px 20px rgba(0,0,0,0.44) inset,
        0 0 0 1px rgba(255,255,255,0.08) inset,
        0 0 34px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.26);
    }

    .btn:active{
      transform: translateY(1px);
      box-shadow:
        0 10px 18px rgba(0,0,0,0.58),
        0 2px 0 rgba(255,255,255,0.08) inset,
        0 -14px 22px rgba(0,0,0,0.46) inset,
        0 0 0 1px rgba(255,255,255,0.06) inset,
        0 0 22px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18);
    }
.btn:hover{
      filter:brightness(1.04) saturate(1.05);
      transform:translateY(-2px);
      box-shadow:
        0 18px 34px rgba(0,0,0,0.62),
        0 0 0 1px rgba(255,255,255,0.09) inset,
        0 0 28px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.42);
    }
    .btn:active{
      transform: translateY(1px) scale(0.99);
      filter:brightness(0.98) saturate(1.02);
      box-shadow:
        0 10px 20px rgba(0,0,0,0.60),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 6px 0 rgba(0,0,0,0.26) inset,
        0 -8px 12px rgba(255,255,255,0.05) inset,
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.20);
    }

    /* Range sliders (brush size etc.) — darker accent */
    .btn:active{
      transform:translateY(0px) scale(0.99);
      filter:brightness(0.98);
      box-shadow:
        0 10px 22px rgba(0,0,0,0.58),
        0 0 0 1px rgba(255,255,255,0.06) inset,
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.28);
    }

    .btn.ghost{
      position:relative;
      background:
        linear-gradient(145deg, rgba(15,23,34,0.78), rgba(11,20,32,0.88)),
        linear-gradient(135deg,
          rgba(120,80,255,0.10),
          rgba(255,80,190,0.08),
          rgba(0,255,240,0.06),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.10));
      color:var(--fg);
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:
        0 10px 22px rgba(0,0,0,0.55),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
    }
    .btn.ghost:hover{
      border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.60),
        0 0 0 1px rgba(255,255,255,0.07) inset,
        0 0 26px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.30);
    }

    .btn.small{padding:8px 12px;border-radius:10px;font-weight:700}
    #status{margin-left:auto;display:flex;align-items:center;gap:10px;color:var(--muted);font-size:.9em}
    .dot{width:12px;height:12px;border-radius:999px;background:#666;box-shadow:0 0 0 2px rgba(255,255,255,.06) inset}
    .dot.ok{background:#36D399}.dot.warn{background:#F87171}

    .stage{position:relative;display:flex;align-items:center;justify-content:center;width:100%;height:100%;overflow:hidden}
    .videoWrap{position:relative;width:100%;height:100%;max-width:100vw;max-height:100vh;background:#000;overflow:hidden;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--border)}
    /* Убираем красную рамку в overlay режиме */
    body.overlay-mode #overlay{border:none !important;}
    iframe{width:100%;height:100%;border:0;display:block;object-fit:contain}
    #overlay{position:absolute;inset:0;width:100%;height:100%;touch-action:none;pointer-events:auto}
    #fx-layer{position:absolute;inset:0;pointer-events:none;overflow:visible}
    /* CHAT: сайт (левая панель) */

    .chat-panel{
      position:fixed; left:16px; top:96px; width:340px; max-height:65vh; z-index:120;
      border-radius:18px;
      display:flex; flex-direction:column;
      user-select:none;
      --chat-font: 14px;
      font-size: var(--chat-font);
      resize:both; min-width:280px; min-height:200px; height:min(50vh, 420px);

      /* container frame */
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:
        0 20px 48px rgba(0,0,0,0.62),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 30px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18);

      /* IMPORTANT: avoid text/layout glitches from backdrop-filter on the same node that scrolls */
      background: transparent;
      overflow:hidden;
    }

    /* Decorative background layer (all blur/glow lives here) */
    .chat-panel .chat-bg{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(460px 320px at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.16),
          rgba(120,80,255,0.10) 35%,
          rgba(255,80,190,0.08) 55%,
          rgba(0,0,0,0) 74%),
        linear-gradient(145deg, rgba(15,23,34,0.80), rgba(11,20,32,0.92)),
        linear-gradient(135deg,
          rgba(120,80,255,0.14),
          rgba(255,80,190,0.10),
          rgba(0,255,240,0.08),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.14));
      filter: blur(12px) saturate(1.35);
      opacity:0.92;
      mix-blend-mode: screen;

      /* blur glass */
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    /* Content shell (normal layout flow, no filters) */
    .chat-panel .chat-shell{
      position:relative;
      z-index:1;
      height:100%;
      display:flex;
      flex-direction:column;
    }
.chat-panel.collapsed{ /* свёрнутый чат = только шапка */
      height:auto;
    }
    .chat-panel.collapsed .chat-shell{height:auto;}
.chat-header{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 14px;
      color:rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.98);
      font-weight:900; font-size:0.92em; letter-spacing:0.06em;
      border-bottom:1px solid rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);

      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)),
        linear-gradient(135deg,
          rgba(120,80,255,0.12),
          rgba(255,80,190,0.10),
          rgba(0,255,240,0.08),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.12));
      box-shadow: 0 10px 18px rgba(0,0,0,0.45);
      cursor:move;
      touch-action: none;
    }

    .chat-header-left{display:flex;align-items:center;gap:8px}
    .chat-badge{background:linear-gradient(135deg,var(--accent),var(--accent-2));color:#041f1e;font-size:0.75em;font-weight:900;padding:2px 8px;border-radius:10px;min-width:20px;text-align:center}
    .chat-body{
      padding:12px; display:flex; flex-direction:column; gap:8px;
      overflow-y:auto; overflow-x:hidden;
      min-height:120px; max-height:50vh;
      scrollbar-width:thin;
      scrollbar-color:rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.55) rgba(30,38,51,0.28);
    }
    .chat-body::-webkit-scrollbar{width:8px}
    .chat-body::-webkit-scrollbar-track{background:rgba(30,38,51,0.3);border-radius:4px}
    .chat-body::-webkit-scrollbar-thumb{background:linear-gradient(180deg, rgba(0,0,0,0.40), rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.55)); border-radius:4px}
    .chat-body::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg, rgba(0,0,0,0.35), rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.70))}

    .chat-msg{
      position:relative;
      isolation:isolate; /* keep blend effects from eating text */
      display:block;
      min-height:44px;
      color: var(--fg);
      line-height: 1.4;
      font-size: 1em;
background:
        linear-gradient(145deg, rgba(15,23,34,0.62), rgba(11,20,32,0.90)),
        linear-gradient(135deg,
          rgba(120,80,255,0.14),
          rgba(255,80,190,0.10),
          rgba(0,255,240,0.08),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.14));
      border:1px solid rgba(255,255,255,0.10);
      border-radius:14px;
      padding:12px 12px;
      word-break:break-word;
      box-shadow:
        0 14px 26px rgba(0,0,0,0.58),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.16);
      transition:transform 0.15s ease, box-shadow 0.15s ease, border-color .15s ease, filter .15s ease;
      cursor:pointer;
      overflow:hidden;
    }
    /* Shine UNDER text */
    .chat-msg::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      z-index:0;
      background:
        radial-gradient(300px 220px at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18) 0%,
          rgba(255,255,255,0.08) 22%,
          rgba(0,0,0,0) 70%);
      opacity:0.9;
      mix-blend-mode: screen;
    }
    /* Ensure content is ABOVE effects */
    .chat-msg > *{ position:relative; z-index:1; }

    .chat-msg:hover{
      transform:translateX(2px) translateY(-1px);
      filter:brightness(1.04) saturate(1.05);
      border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.35);
      box-shadow:
        0 18px 30px rgba(0,0,0,0.64),
        0 0 0 1px rgba(255,255,255,0.06) inset,
        0 0 26px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.24);
    }
/* Свои сообщения */
    .chat-msg.own-message{
      background:
        linear-gradient(180deg,
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.24),
          rgba(11,20,32,0.88)),
        linear-gradient(135deg,
          rgba(120,80,255,0.14),
          rgba(255,80,190,0.10),
          rgba(0,255,240,0.08),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18));
      border:1px solid rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.34);
      box-shadow:
        0 14px 26px rgba(0,0,0,0.62),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 26px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.24);
    }
    .chat-msg.own-message .chat-msg-text{ margin-top:6px; white-space:pre-wrap; }
.chat-msg-header{
      flex-direction:row-reverse;
    }
    .chat-msg.replying{
      border:2px solid var(--accent);
      box-shadow:0 0 12px rgba(22,199,183,0.4);
      animation:pulse-reply 1s ease-in-out infinite;
    }
    @keyframes pulse-reply {
      0%, 100% { box-shadow:0 0 12px rgba(22,199,183,0.4); }
      50% { box-shadow:0 0 20px rgba(22,199,183,0.6); }
    }
    .chat-msg-reply-preview{
      background:rgba(22,199,183,0.1);
      border-left:3px solid var(--accent);
      border-radius:6px;
      padding:6px 8px;
      margin-bottom:6px;
      font-size:0.85em;
      color:var(--muted);
      cursor:pointer;
      transition:background 0.2s;
    }
    .chat-msg-reply-preview:hover{
      background:rgba(22,199,183,0.15);
    }
    .chat-msg-reply-preview b{
      color:var(--accent);
      font-size:0.9em;
    }
    .chat-msg-reply-cancel{
      position:absolute;
      top:0;
      right:0;
      background:rgba(239,68,68,0.8);
      border:none;
      color:#fff;
      padding:4px 8px;
      border-radius:0 12px 0 8px;
      cursor:pointer;
      font-size:0.75em;
      font-weight:700;
      opacity:0;
      transition:opacity 0.2s;
    }
    .chat-msg.replying .chat-msg-reply-cancel{
      opacity:1;
    }
    .chat-msg-reply-cancel:hover{
      background:rgba(239,68,68,1);
    }
    /* Контекстное меню */
    .chat-context-menu{
      position:fixed;
      background:linear-gradient(145deg,rgba(15,23,34,0.98),rgba(11,20,32,1));
      border:1px solid rgba(22,199,183,0.3);
      border-radius:8px;
      padding:4px;
      z-index:9999;
      box-shadow:0 8px 24px rgba(0,0,0,0.6);
      backdrop-filter:blur(12px);
      min-width:120px;
      display:none;
    }
    .chat-context-menu.show{
      display:block;
    }
    .chat-context-menu-item{
      padding:8px 12px;
      cursor:pointer;
      border-radius:6px;
      transition:background 0.2s;
      color:var(--fg);
      font-size:0.9em;
    }
    .chat-context-menu-item:hover{
      background:rgba(22,199,183,0.2);
    }
    .chat-context-menu-item.danger{
      color:#ef4444;
    }
    .chat-context-menu-item.danger:hover{
      background:rgba(239,68,68,0.2);
    }
    /* Редактирование сообщения */
    .chat-msg-editing{
      border:2px solid #fbbf24;
      box-shadow:0 0 12px rgba(251,191,36,0.4);
      animation:pulse-edit 1s ease-in-out infinite;
    }
    @keyframes pulse-edit {
      0%, 100% { box-shadow:0 0 12px rgba(251,191,36,0.4); }
      50% { box-shadow:0 0 20px rgba(251,191,36,0.6); }
    }
    .chat-msg-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .chat-msg-actions{
      display:flex;
      gap:4px;
      opacity:0;
      transition:opacity 0.2s;
    }
    .chat-msg:hover .chat-msg-actions{
      opacity:1;
    }
    .chat-msg-action-btn{
      background:rgba(22,199,183,0.2);
      border:none;
      color:var(--fg);
      padding:4px 8px;
      border-radius:6px;
      cursor:pointer;
      font-size:0.75em;
      font-weight:700;
      transition:background 0.2s;
    }
    .chat-msg-action-btn:hover{
      background:rgba(22,199,183,0.4);
    }
    .chat-msg-action-btn.danger{
      background:rgba(239,68,68,0.2);
      color:#ef4444;
    }
    .chat-msg-action-btn.danger:hover{
      background:rgba(239,68,68,0.4);
    }
    .chat-input{
      display:flex; gap:8px; padding:10px;
      border-top:1px solid rgba(22,199,183,0.15);
      background:rgba(0,0,0,0.2);
    }
    .chat-input input{
      flex:1;
      background:rgba(11,20,32,0.6);
      border:1px solid rgba(22,199,183,0.25);
      color:var(--fg);
      padding:10px 14px;
      border-radius:10px;
      font-size:.95em;
      outline:none;
      transition:border-color 0.2s, box-shadow 0.2s;
    }
    .chat-input input:focus{
      border-color:rgba(22,199,183,0.5);
      box-shadow:0 0 0 3px rgba(22,199,183,0.1);
    }
    .chat-hidden{display:none}

    /* CHAT: оверлей (появляется на 15с, С ПОЛЕМ ВВОДА) - СКРЫТ ОТ OBS */
    .chat-overlay{
      position:absolute; left:16px; bottom:16px; width:min(40vw,480px); z-index:115;
      background:linear-gradient(145deg,rgba(15,23,34,0.92),rgba(11,20,32,0.95));
      border:1px solid rgba(22,199,183,0.25); border-radius:14px; backdrop-filter:blur(12px);
      display:flex; flex-direction:column; overflow:hidden; resize: both; min-width:260px; min-height:160px; height:min(50vh, 420px); 
      box-shadow:0 8px 24px rgba(0,0,0,.5), 0 0 0 1px rgba(22,199,183,0.15) inset;
      opacity:0; transform:translateY(10px); transition:opacity .25s ease, transform .25s ease; pointer-events:none;
      /* КРИТИЧНО: создаем изолированный слой для защиты от захвата экрана */
      will-change: transform, opacity;
      isolation: isolate;
      contain: layout style paint;
    }
    .chat-overlay.show{opacity:1; transform:none; pointer-events:auto !important;}
    .chat-overlay.show *{pointer-events:auto !important;}
    .chat-overlay .chat-body{padding:10px; gap:6px; flex:1; overflow-y:auto; max-height:none;}
    .chat-overlay .chat-msg{background:linear-gradient(135deg,rgba(22,199,183,0.08),rgba(14,165,160,0.05)); border:1px solid rgba(22,199,183,0.15);}
    /* Поле ввода в overlay-чате */
    .chat-overlay .chat-input{display:flex; gap:6px; padding:8px; border-top:1px solid rgba(22,199,183,0.15); background:rgba(0,0,0,0.3);}
    .chat-overlay .chat-input input{flex:1; background:rgba(11,20,32,0.7); border:1px solid rgba(22,199,183,0.3); color:var(--fg); padding:8px 12px; border-radius:8px; font-size:.9em; outline:none;}
    .chat-overlay .chat-input input:focus{border-color:rgba(22,199,183,0.6); box-shadow:0 0 0 2px rgba(22,199,183,0.15);}
    .chat-overlay .chat-input .btn{padding:8px 14px; font-size:.85em;}

    /* EMOJI particle — летящие эмодзи с цветной обводкой */
    .emoji { 
      position: absolute; 
      font-size: 40px; 
      pointer-events: none; 
      user-select: none;
      will-change: transform, opacity;
    }
    .emoji.stroke {
      text-shadow:
        -3px -3px 0 var(--emoji-stroke),
        3px -3px 0 var(--emoji-stroke),
        -3px 3px 0 var(--emoji-stroke),
        3px 3px 0 var(--emoji-stroke),
        -3px 0 0 var(--emoji-stroke),
        3px 0 0 var(--emoji-stroke),
        0 -3px 0 var(--emoji-stroke),
        0 3px 0 var(--emoji-stroke),
        0 0 12px var(--emoji-stroke) !important; /* !important для приоритета над другими стилями */
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4)) !important; /* Тень для всего */
    }

    /* Цветные эмодзи через grayscale + overlay (как на гейте) */
    .emoji-wrap{
      position:absolute;
      pointer-events:none;
      user-select:none;
      will-change: transform, opacity;
      display:inline-block;
      width: 1em;
      height: 1em;
    }
    .emoji-char{
      position:relative;
      font-size:1em;
      line-height:1;
      filter: grayscale(100%);
      z-index:1;
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
      height:100%;
    }
    .emoji-tint{
      position:absolute;
      inset:0;
      background-color: var(--emoji-color, transparent);
      mix-blend-mode: color;
      pointer-events:none;
      z-index:2;
    }
    .emoji-char.stroke{
      text-shadow:
        -3px -3px 0 var(--emoji-stroke),
        3px -3px 0 var(--emoji-stroke),
        -3px 3px 0 var(--emoji-stroke),
        3px 3px 0 var(--emoji-stroke),
        0 0 10px rgba(0,0,0,0.35);
    }


    /* Для PNG: отдельно filter с !important */
    .emoji.stroke img {
      filter: 
        drop-shadow(-3px -3px 0 var(--emoji-stroke))
        drop-shadow(3px -3px 0 var(--emoji-stroke))
        drop-shadow(-3px 3px 0 var(--emoji-stroke))
        drop-shadow(3px 3px 0 var(--emoji-stroke))
        drop-shadow(-3px 0 0 var(--emoji-stroke))
        drop-shadow(3px 0 0 var(--emoji-stroke))
        drop-shadow(0 -3px 0 var(--emoji-stroke))
        drop-shadow(0 3px 0 var(--emoji-stroke))
        drop-shadow(0 0 12px var(--emoji-stroke)) !important;
    }

    /* BLUR GATE */
    .blur-wrap{filter:blur(var(--blur)); pointer-events:none; user-select:none}

    .gate{
      position:fixed; inset:0; display:grid; place-items:center; z-index:9999;
      background:linear-gradient(180deg, rgba(11,18,22,.82), rgba(11,18,22,.92));
      backdrop-filter: blur(6px);
      pointer-events:auto;
    }
    .gate-card{
      width:min(600px,92vw); background:rgba(12,20,28,.9); border:1px solid var(--border);
      border-radius:18px; padding:24px; text-align:center; box-shadow:0 12px 36px rgba(0,0,0,.5);
      transform:translateZ(0);
    }
    .gate-title{font-family:'Montserrat',sans-serif; font-weight:800; font-size:28px; color:var(--accent); margin-bottom:12px}
    .gate-sub{color:var(--muted); margin-bottom:8px}
    .gate-hint{color:#ef9a9a; font-size:.95em; min-height:1.2em; margin-bottom:10px; opacity:0; transition:opacity .2s}
    .gate-hint.show{opacity:1}

    .gate-form{display:grid; grid-template-columns:1fr 170px; gap:14px; align-items:center}
    .field{display:flex; align-items:center; gap:10px; justify-content:space-between}
    .field label{color:var(--muted); font-weight:700}
    .in{
      background:var(--input-bg); color:var(--fg); border:1px solid var(--input-border); border-radius:12px; padding:12px 14px; outline:none
    }
    .in.big{font-size:18px}
    .in[type="color"]{appearance:none;width:44px;height:44px;border-radius:10px;border:1px solid var(--input-border);padding:2px;background:var(--input-bg);cursor:pointer}
    .in[type="color"]::-webkit-color-swatch{border:none;border-radius:6px}

    /* error effects */
    @keyframes shake {
      10%, 90% { transform: translateX(-2px); }
      20%, 80% { transform: translateX(4px); }
      30%, 50%, 70% { transform: translateX(-6px); }
      40%, 60% { transform: translateX(6px); }
    }
    .gate-card.error { animation: shake .35s ease; }
    .in.error { border-color:#ef4444 !important; box-shadow:0 0 0 3px rgba(239,68,68,.2); }

    footer{
      padding:14px 20px;
      color:rgba(230,237,243,0.82);
      font-size:.9em;
      text-align:center;

      position:relative;
      background:
        linear-gradient(180deg, rgba(11,20,32,0.92), rgba(10,16,26,0.96));
      border-top:1px solid rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);
      box-shadow:
        0 -10px 26px rgba(0,0,0,0.55),
        0 0 30px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.08);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      overflow:hidden;
    }
    footer::before{
      content:"";
      position:absolute; inset:-1px;
      pointer-events:none;
      background:
        radial-gradient(900px 220px at var(--mx) var(--my),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.14),
          rgba(120,80,255,0.10) 40%,
          rgba(255,80,190,0.08) 60%,
          rgba(0,0,0,0) 75%);
      mix-blend-mode: screen;
      opacity:0.85;
    }
    footer > *{position:relative; z-index:1;}

    .hidden{display:none!important}

    @media (max-width:768px){
      header{flex-direction:column;align-items:stretch;gap:10px;padding:10px}
      .brand{text-align:center;font-size:1.4em}
      #status{margin-left:0;justify-content:center}
      .chat-panel{left:8px; top:auto; bottom:80px; width:calc(100vw - 16px); max-width:420px; max-height:45vh}
      .chat-body{max-height:35vh}
      .gate-form{grid-template-columns:1fr}
      .field{justify-content:flex-start}
      #reactionsBar{flex-wrap:wrap;justify-content:center;margin-left:0}
    }
    /* В конце секции <style> */
    .gate-form .btn {
      pointer-events: auto; /* Убедимся, что кнопка всегда кликабельна */
      opacity: 1; /* Убедимся, что кнопка всегда видна */
    }
    .gate-form .btn:disabled {
      pointer-events: none;
      opacity: 0.6;
    }

    /* Панель эмодзи для оверлея */
    .overlay-emoji-panel {
        position: fixed;
        bottom: 110px; left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(15, 23, 34, 0.9);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(22, 199, 183, 0.3);
        border-radius: 16px;
        padding: 12px;
        display: flex;
        flex-wrap: wrap;            /* две строки */
        gap: 8px;
        width: min(560px, calc(100vw - 24px)); /* чтобы реально переносилось в 2 строки */
        max-height: 112px;          /* ~2 строки кнопок */
        overflow-x: hidden;
        overflow-y: hidden;
        opacity: 0; pointer-events: none;
        transition: 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        z-index: 10000;
    }
    .overlay-emoji-panel.show {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
    }
    .overlay-emoji-panel button {
        font-size: 1.5em !important;
        cursor: pointer;
        flex: 0 0 auto;
    }


    /* === СТИЛИ ДЛЯ ВЫБОРА ЭМОДЗИ (НОВОЕ) === */
    .emoji-setup-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    .preview-container {
      position: relative;
      width: 120px;
      height: 120px;
      background: var(--panel);
      border-radius: 50%;
      border: 4px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }
    .emoji-layer {
      font-size: 56px;
      line-height: 1;
      filter: grayscale(100%);
      z-index: 1;
    }
    .color-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-color: transparent;
      z-index: 2;
      mix-blend-mode: color; /* Окрашивает эмодзи */
      pointer-events: none;
    }
    /* Сетка выбора */
    .emoji-grid {
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      max-width: 300px;
    }
    .emoji-setup-container.open .emoji-grid{display:grid;}
    .emoji-setup-container .preview-container{cursor:pointer;}
    .emoji-setup-container:not(.open) .emoji-grid{display:none;}

    .emoji-btn {
      position:relative;
      background:
        linear-gradient(145deg, rgba(15,23,34,0.78), rgba(11,20,32,0.88)),
        linear-gradient(135deg,
          rgba(120,80,255,0.12),
          rgba(255,80,190,0.10),
          rgba(0,255,240,0.08),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.14));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      font-size: 20px;
      cursor: pointer;
      padding: 7px 6px;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease, filter .18s ease;
      box-shadow:
        0 10px 18px rgba(0,0,0,0.55),
        0 0 0 1px rgba(255,255,255,0.05) inset,
        0 0 16px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.14);
      overflow:hidden;
    }
    .emoji-btn::after{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background: radial-gradient(160px 120px at var(--mx) var(--my),
        rgba(255,255,255,0.08),
        rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.12) 35%,
        rgba(0,0,0,0) 75%);
      mix-blend-mode: screen;
      opacity:0.9;
    }
    .emoji-btn:hover {
      filter: brightness(1.06) saturate(1.08);
      transform: translateY(-2px);
      border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.55);
      box-shadow:
        0 14px 22px rgba(0,0,0,0.60),
        0 0 0 1px rgba(255,255,255,0.06) inset,
        0 0 22px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.28);
    }
    .emoji-btn.active {
      background:
        linear-gradient(180deg,
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.92),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.60)),
        linear-gradient(135deg,
          rgba(120,80,255,0.16),
          rgba(255,80,190,0.14),
          rgba(0,255,240,0.10),
          rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22));
      border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.65);
      transform: translateY(-1px) scale(1.08);
      box-shadow:
        0 14px 24px rgba(0,0,0,0.62),
        0 0 0 1px rgba(255,255,255,0.07) inset,
        0 0 28px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.38);
    }

    
    /* Скрываем старый input цвета, но оставляем функционал */
    #colorPickerInput { margin-top: 10px; width: 100%; height: 40px; cursor: pointer; }


  
    /* ===== Overlay toast for new messages (overlay mode only) ===== */
    .overlay-toast{
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 14px;
      background: rgba(11, 20, 32, 0.86);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      opacity: 0;
      pointer-events: none;
      z-index: 9999;
      max-width: min(720px, calc(100vw - 24px));
      transition: opacity 0.15s ease, transform 0.15s ease;
      color: var(--fg);
    }
    .overlay-toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    .overlay-toast .ot-emoji{
      width: 54px;
      height: 54px;
      border-radius: 16px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 34px;
      line-height: 1;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-color: color-mix(in srgb, var(--ot-color) 45%, rgba(255,255,255,0.10));
      box-shadow: 0 6px 18px rgba(0,0,0,0.28);
      flex: 0 0 auto;
      filter: drop-shadow(0 0 8px rgba(0,0,0,0.35));
    }
    .overlay-toast .ot-emoji-glyph{
      display:block;
      filter: grayscale(1);
      /* свечение именно вокруг глифа, а не вокруг бокса */
      text-shadow:
        0 0 10px color-mix(in srgb, var(--ot-color) 70%, transparent),
        0 0 18px color-mix(in srgb, var(--ot-color) 55%, transparent);
    }
    .overlay-toast .ot-text{
      font-size: 28px;
      line-height: 1.35;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: min(900px, calc(100vw - 160px));
    }
    .overlay-toast[data-color="1"]{
      border-color: color-mix(in srgb, var(--ot-color) 55%, rgba(255,255,255,0.12));
      box-shadow: 0 10px 30px rgba(0,0,0,0.40), 0 0 30px color-mix(in srgb, var(--ot-color) 60%, transparent);
    }

  
/* --- Telegram link modal (restored styles) --- */
.link-modal{
  position:fixed; inset:0;
  display:none;
  align-items:center; justify-content:center;
  padding:18px;
  background:rgba(0,0,0,.55);
  z-index:9999;
}
.link-modal.show{ display:flex; }
.link-modal-content{
  width:min(520px, 96vw);
  background:rgba(12,12,12,.92);
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  padding:16px 16px 14px;
  box-shadow:0 10px 40px rgba(0,0,0,.55);
}
.link-code{
  user-select:none;
  cursor:pointer;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:20px;
  letter-spacing:0.04em;
  padding:10px 12px;
  border-radius:10px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  text-align:center;
}
.link-modal-buttons{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
#toggleSelfClusters{ display:inline-flex !important; }



/* === CHAT HARD OVERRIDE v2 (fix tiny rows / hidden text) ===
   Purpose: telegram_link_styles.css (or older rules) sometimes force fixed heights / center alignment.
   We override very specifically for the site chat list container.
*/
#chatListSite{
  display:flex !important;
  flex-direction:column !important;
  gap:10px !important;
  padding:10px !important;
}

/* direct message nodes created by renderChat are direct children of #chatListSite */
#chatListSite > div{
  height:auto !important;
  min-height:56px !important;
  overflow:visible !important;
  display:flex !important;
  flex-direction:column !important;
  align-items:flex-start !important;
  justify-content:flex-start !important;

  padding:12px 14px !important;
  border-radius:14px !important;

  /* keep your neon/glass look */
  background:linear-gradient(145deg, rgba(255,255,255,0.06), rgba(0,0,0,0.24)) !important;
  border:1px solid rgba(255,255,255,0.10) !important;
  box-shadow:
    0 10px 26px rgba(0,0,0,0.55),
    0 0 0 1px rgba(255,255,255,0.05) inset,
    0 0 22px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18) !important;
}

/* author line (often first child) */
#chatListSite > div > b,
#chatListSite > div .chat-author,
#chatListSite > div .author{
  display:block !important;
  font-weight:800 !important;
  letter-spacing:0.2px !important;
  margin:0 0 6px 0 !important;
  line-height:1.1 !important;
}

/* message text */
#chatListSite{
  font-size: var(--chat-font, 14px) !important;
}

#chatListSite > div,
#chatListSite > div *{
  line-height:1.35 !important;
  font-size: inherit !important;
}

#chatListSite > div .chat-msg-text,
#chatListSite > div .text,
#chatListSite > div p,
#chatListSite > div span{
  white-space:pre-wrap !important;
  word-break:break-word !important;
  overflow-wrap:anywhere !important;
}

/* === BUTTONS: more 3D + accent-tinted highlight === */
button, .btn{
  transform: translateZ(0);
}

.btn{
  box-shadow:
    0 14px 36px rgba(0,0,0,0.62),
    0 0 0 1px rgba(255,255,255,0.07) inset,
    0 2px 0 rgba(255,255,255,0.08) inset,
    0 -10px 18px rgba(0,0,0,0.42) inset,
    0 0 28px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);
}

.btn::before{
  /* highlight sheen tinted toward account accent */
  background:
    radial-gradient(140% 120% at 20% 10%,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.28),
      rgba(255,255,255,0.10) 38%,
      rgba(255,255,255,0.00) 70%);
  opacity:0.85;
}

.btn:active{
  transform: translateY(2px);
  box-shadow:
    0 8px 20px rgba(0,0,0,0.55),
    0 0 0 1px rgba(255,255,255,0.06) inset,
    0 -6px 12px rgba(0,0,0,0.46) inset;
}

/* danger buttons: keep standard red, do NOT get tinted */
.btn.danger,
button.danger{
  background: linear-gradient(180deg, rgba(255,70,70,0.95), rgba(170,20,20,0.95)) !important;
  border-color: rgba(255,90,90,0.55) !important;
  box-shadow:
    0 14px 34px rgba(0,0,0,0.62),
    0 0 0 1px rgba(255,255,255,0.06) inset,
    0 0 28px rgba(255,70,70,0.22) !important;
}
/* === RANGES: darker-than-accent track === */
/* chat scrollbar darker */
#chatListSite::-webkit-scrollbar-thumb,
.chat-body::-webkit-scrollbar-thumb{
  background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45)) !important;
  border:2px solid rgba(10,14,20,0.65) !important;
}

input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      height:10px;
      border-radius:999px;
      background: linear-gradient(90deg,
        rgba(0,0,0,0.55),
        rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.35));
      border:1px solid rgba(255,255,255,0.10);
      box-shadow:
        0 10px 18px rgba(0,0,0,0.55),
        0 0 0 1px rgba(255,255,255,0.05) inset;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;height:18px;border-radius:999px;
      background: radial-gradient(circle at 30% 25%,
        rgba(255,255,255,0.28),
        rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.95) 55%,
        rgba(0,0,0,0.35) 100%);
      border:1px solid rgba(255,255,255,0.16);
      box-shadow:
        0 12px 22px rgba(0,0,0,0.62),
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);
      cursor:pointer;
    }
    input[type="range"]::-moz-range-thumb{
      width:18px;height:18px;border-radius:999px;
      background: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.95);
      border:1px solid rgba(255,255,255,0.16);
      box-shadow:
        0 12px 22px rgba(0,0,0,0.62),
        0 0 18px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22);
      cursor:pointer;
    }


/* danger buttons: visually same as other buttons (no special red) */
.btn.danger{ }


/* === ACCENT ACTION BUTTONS === */
#sendBtn, #logoutBtn, #clearBtn, #deleteVotesBtn,
.btn.send, .btn.logout, .btn.clear, .btn.delete-votes {
  background:
    linear-gradient(180deg,
      rgba(255,255,255,0.14),
      rgba(0,0,0,0.18)),
    linear-gradient(135deg,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.18));
  box-shadow:
    0 18px 34px rgba(0,0,0,0.68),
    0 4px 0 rgba(255,255,255,0.14) inset,
    0 -12px 22px rgba(0,0,0,0.46) inset,
    0 0 36px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.35);
}

#sendBtn::before, #logoutBtn::before, #clearBtn::before, #deleteVotesBtn::before,
.btn.send::before, .btn.logout::before, .btn.clear::before, .btn.delete-votes::before {
  background:
    radial-gradient(140px 70px at 20% 20%,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.55),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.0) 70%),
    linear-gradient(180deg,
      rgba(255,255,255,0.22),
      rgba(255,255,255,0.0));
}


/* === REMOVE ONLINE INDICATOR === */
.online-indicator,
.online-status,
#onlineIndicator,
#onlineStatus {
  display:none !important;
}


/* === ACCENT ACTION BUTTONS (FIX IDS) ===
   targets: send/logout/clear/delete-votes/toggle-tool (vote/draw)
   overrides any .danger / telegram_link_styles.css */
#chatSend.btn,
#logout.btn,
#toolClear.btn,
#btnDeleteVotes.btn,
#toolToggle.btn{
  border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45) !important;
  background:
    linear-gradient(180deg,
      rgba(255,255,255,0.16),
      rgba(0,0,0,0.20)) !important,
    linear-gradient(135deg,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.62),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22)) !important;

  box-shadow:
    0 18px 34px rgba(0,0,0,0.70),
    0 4px 0 rgba(255,255,255,0.14) inset,
    0 -12px 22px rgba(0,0,0,0.46) inset,
    0 0 36px rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.40) !important;
  filter: saturate(1.08);
}

#chatSend.btn::before,
#logout.btn::before,
#toolClear.btn::before,
#btnDeleteVotes.btn::before,
#toolToggle.btn::before{
  background:
    radial-gradient(150px 75px at 22% 18%,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.62),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.00) 70%) !important,
    linear-gradient(180deg,
      rgba(255,255,255,0.22),
      rgba(255,255,255,0.00)) !important;
  opacity:0.98 !important;
}

#chatSend.btn::after,
#logout.btn::after,
#toolClear.btn::after,
#btnDeleteVotes.btn::after,
#toolToggle.btn::after{
  background:
    radial-gradient(260px 140px at var(--mx) var(--my),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.38),
      rgba(0,0,0,0) 72%) !important;
  opacity:0.62 !important;
}

/* make sure "danger" utility never forces red for these */
#toolClear.danger,
#btnDeleteVotes.danger{
  color: var(--fg) !important;
}


/* === FORCE ACCENT FOR CLEAR/DELETE (beats .danger red fill) === */
#toolClear,
#btnDeleteVotes,
#toolClear.danger,
#btnDeleteVotes.danger{
  background-color: transparent !important;
  background-image:
    linear-gradient(180deg, rgba(255,255,255,0.16), rgba(0,0,0,0.20)),
    linear-gradient(135deg,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.64),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22)) !important;
  background: 
    linear-gradient(180deg, rgba(255,255,255,0.16), rgba(0,0,0,0.20)),
    linear-gradient(135deg,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.64),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.22)) !important;
  border-color: rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.45) !important;
  color: var(--fg) !important;
}

/* if red comes from pseudo elements, kill them too */
#toolClear::before, #btnDeleteVotes::before,
#toolClear::after,  #btnDeleteVotes::after{
  background: none !important;
}

/* re-add accent sheen/glow on top of the forced base */
#toolClear::before, #btnDeleteVotes::before{
  content:"" !important;
  position:absolute !important;
  inset:1px 1px auto 1px !important;
  height:52% !important;
  border-radius:13px !important;
  pointer-events:none !important;
  mix-blend-mode: screen !important;
  background:
    radial-gradient(150px 75px at 22% 18%,
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.62),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.00) 70%),
    linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.00)) !important;
  opacity:0.98 !important;
}

#toolClear::after, #btnDeleteVotes::after{
  content:"" !important;
  position:absolute !important;
  inset:-1px !important;
  border-radius:15px !important;
  pointer-events:none !important;
  filter: blur(10px) !important;
  background:
    radial-gradient(260px 140px at var(--mx) var(--my),
      rgba(var(--acc-r),var(--acc-g),var(--acc-b),0.38),
      rgba(0,0,0,0) 72%) !important;
  opacity:0.62 !important;
}


    /* === CINEMA / FULLSCREEN UI TOGGLE + 2-row header === */
    #mainHeader{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
    }
    .header-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    #headerTop{
      transition: transform .28s ease, opacity .28s ease, max-height .28s ease, padding .28s ease, margin .28s ease;
      transform: translateY(0);
      opacity: 1;
      max-height: 260px;
      overflow: hidden;
    }
    #mainFooter{
      transition: transform .28s ease, opacity .28s ease, max-height .28s ease, padding .28s ease, margin .28s ease;
      transform: translateY(0);
      opacity: 1;
      max-height: 260px;
      overflow: hidden;
    }

    body.cinema #headerTop{
      transform: translateY(-110%);
      opacity: 0;
      max-height: 0;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      margin: 0 !important;
      pointer-events: none;
    }
    body.cinema #mainFooter{
      transform: translateY(110%);
      opacity: 0;
      max-height: 0;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      margin: 0 !important;
      pointer-events: none;
    }

</style>
</head>
<body>
<div class="app">
  <header id="mainHeader">
    <div class="header-row" id="headerTop">
      <div class="brand">DepressivePasties</div>

      <!-- инструменты -->
      <div style="display:flex;gap:8px;align-items:center;margin-left:8px" id="toolsBar">
      <button class="btn small" id="toolToggle" title="Переключить голос/рисование">Рисовать</button>
      <button class="btn ghost small" id="toolErase" title="Ластик">Ластик</button>
      <button class="btn ghost small art-only" id="toolFill" title="Заливка" >🪣</button>
      <button class="btn ghost small art-only" id="toolPick" title="Пипетка" style="display:none">🔍</button>
      <button class="btn ghost small danger" id="toolClear" title="Очистить холст">Очистить</button>
      <!-- Размер кисти -->
      <div style="display:flex;gap:6px;align-items:center;margin-left:8px;padding-left:8px;border-left:1px solid var(--border)">
        <label style="color:var(--muted);font-size:0.85em;font-weight:600">Размер:</label>
        <input type="range" id="brushSizeSlider" min="1" max="20" value="4" style="width:100px;cursor:pointer">
        <span id="brushSizeValue" style="color:var(--accent);font-weight:700;font-size:0.9em;min-width:28px;text-align:center">4px</span>
      </div>
    </div>

      <!-- кино-режим: скрыть верх/низ, эмодзи оставить -->
      <button class="btn ghost small" id="btnCinema" title="Скрыть/показать верх и низ (Alt+F)">Fullscreen</button>

      <button class="btn ghost small" id="toggleSelfClusters" title="Показывать голоса (кластеры) у себя на экране">Голоса: скрыты</button>

      <button class="btn ghost small" id="logout" style="margin-left:auto">Выйти</button>

      <div id="status" style="margin-left:6px">
      <span class="dot" id="dot-auth" title="Статус подключения"></span>
      <span id="status-text">Оффлайн</span>
    </div>
    </div>

    <div class="header-row" id="headerEmojis">
      <!-- реакции -->
      <div id="reactionsBar" style="display:flex;gap:8px;align-items:center;margin-left:8px">
      <button id="emoBtn_0" class="btn ghost small" data-emo="👍" style="font-size:1.4em;padding:8px 14px">👍</button>
      <button id="emoBtn_1" class="btn ghost small" data-emo="👎" style="font-size:1.4em;padding:8px 14px">👎</button>
      <button id="emoBtn_2"  class="btn ghost small" data-emo="❤️" style="font-size:1.4em;padding:8px 14px">❤️</button>
      <button id="emoBtn_3"  class="btn ghost small" data-emo="😂" style="font-size:1.4em;padding:8px 14px">😂</button>
      <button id="emoBtn_4"  class="btn ghost small" data-emo="😮" style="font-size:1.4em;padding:8px 14px">😮</button>
      <button id="emoBtn_5"  class="btn ghost small" data-emo="😢" style="font-size:1.4em;padding:8px 14px">😢</button>
      <button id="emoBtn_6"  class="btn ghost small" data-emo="🔥" style="font-size:1.4em;padding:8px 14px">🔥</button>
      <button id="emoBtn_7"  class="btn ghost small" data-emo="🤡" style="font-size:1.4em;padding:8px 14px">🤡</button>
      <button id="emoBtn_8"  class="btn ghost small" data-emo="🤬" style="font-size:1.4em;padding:8px 14px">🤬</button>
      <button id="emoBtn_9"  class="btn ghost small" data-emo="🍷" style="font-size:1.4em;padding:8px 14px">🍷</button>
      <button id="emoBtn_10"  class="btn ghost small" data-emo="🧐" style="font-size:1.4em;padding:8px 14px">🧐</button>
      <button id="emoBtn_11"  class="btn ghost small" data-emo="💃" style="font-size:1.4em;padding:8px 14px">💃</button>
      <button id="emoBtn_12"  class="btn ghost small" data-emo="🚩" style="font-size:1.4em;padding:8px 14px">🚩</button>
      <button id="emoBtn_13"  class="btn ghost small" data-emo="🤷‍♂️" style="font-size:1.4em;padding:8px 14px">🤷‍♂️</button>
      <button id="emoBtn_14"  class="btn ghost small" data-emo="🙄" style="font-size:1.4em;padding:8px 14px">🙄</button>
      <button id="emoBtn_15"  class="btn ghost small" data-emo="💔" style="font-size:1.4em;padding:8px 14px">💔</button>
      <button id="emoBtn_16"  class="btn ghost small" data-emo="🤯" style="font-size:1.4em;padding:8px 14px">🤯</button>
      <button id="emoBtn_17"  class="btn ghost small" data-emo="🔔" style="font-size:1.4em;padding:8px 14px">🔔</button>
      <button class="btn ghost small" data-reaction-type="png" data-reaction-src="images/crying.png" data-reaction-key="плачу" style="font-size:1.4em;padding:8px 14px">
        <img src="images/crying.png" alt="Плачу" style="width: 24px; height: 24px; vertical-align: middle;">
      </button>
      <button class="btn ghost small" data-reaction-type="png" data-reaction-src="images/dancing.png" data-reaction-key="танцую" style="font-size:1.4em;padding:8px 14px">
        <img src="images/dancing.png" alt="Танцую" style="width: 24px; height: 24px; vertical-align: middle;">
      </button>

</div>
    </div>
  </header>

  <!-- CHAT: сайт -->
  <aside class="chat-panel" id="chatPanel">
    <div class="chat-bg"></div>
    <div class="chat-shell">
    <div class="chat-header" id="chatDragHandle">
      <div class="chat-header-left">
        <span>Чат</span>
        <span class="chat-badge hidden" id="chatBadge">0</span>
        <!-- Кнопка привязки Telegram -->
        <button class="btn ghost small link-tg-btn" id="linkTelegramBtn" onclick="showLinkModal()" title="Связать с Telegram">
          📎
        </button>
      </div>
      <div style="display:flex;gap:6px">
        <button class="btn ghost small" id="chatNotifications" title="Уведомления">🔔</button>
        <button class="btn ghost small" id="chatToggle">Свернуть</button>
      </div>
    </div>
    <div class="chat-body" id="chatListSite"></div>
    <div class="chat-input">
      <input id="chatInput" placeholder="Сообщение…" />
      <button class="btn small" id="chatSend">Отправить</button>
    </div>
    </div>
  </aside>

  <main class="stage" id="contentWrap">
    <div class="videoWrap" id="videoWrap">
      <iframe id="player" allow="autoplay; microphone; camera" referrerpolicy="no-referrer"></iframe>
      <canvas id="overlay"></canvas>
      <div id="fx-layer"></div>
      <div id="overlayToast" class="overlay-toast" aria-live="polite"></div>
      <!-- CHAT: оверлей С ПОЛЕМ ВВОДА -->
      <div class="chat-overlay" id="chatOverlay">
        <div class="chat-body" id="chatListOverlay"></div>
        <div class="chat-input">
          <input id="chatInputOverlay" placeholder="Сообщение…" />
          <button class="btn small" id="chatSendOverlay">→</button>
        </div>
      </div>
    </div>
  </main>

  <footer id="mainFooter">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px">
      <div>Тап по видео ставит/переставляет маркер. Alt+F7 — показать/скрыть чат в оверлее. ПИН входа: 1111.</div>
      <div style="display:flex;gap:8px">
        <button class="btn ghost small" id="artColorDot" title="Цвет (арт-режим)" style="display:none;width:32px;height:32px;border-radius:999px;padding:0;border:1px solid var(--border)"></button>
        <input type="color" id="artColorPicker" value="#16c7b7" style="position:absolute;left:-9999px;opacity:0;width:1px;height:1px"/>
        <button class="btn ghost small danger" id="btnDeleteVotes" title="Удалить все голоса">Удалить голоса</button>
      </div>
    </div>
  </footer>
</div>

<!-- ВХОДНОЙ ГЕЙТ -->
<div class="gate" id="gate">
  <div class="gate-card" id="gateCard">
    <div class="gate-title">DepressivePasties</div>
    <div class="gate-sub">Введи Имя, выбери Цвет и ПИН. Контент пока под замком 👀</div>
    <div class="gate-hint" id="gateHint"></div>
    <!-- === EMOJI SETUP === -->
    <div class="emoji-setup-container">
      <div class="preview-container">
        <div id="emojiDisplay" class="emoji-layer"></div>
      </div>
      <div class="emoji-grid" id="emojiGrid"></div>
    </div>

<div class="gate-form">
      <div class="field"><label for="gateName">Имя</label><input id="gateName" class="in big" placeholder="Твоё имя"/></div>
      <div class="field"><label for="gateColor">Цвет</label><input id="gateColor" type="color" class="in" value="#16c7b7"/></div>
      <div class="field"><label for="gatePin">ПИН</label><input id="gatePin" class="in big" placeholder="••••" inputmode="numeric" pattern="[0-9]*" maxlength="8"/></div>
      <div class="field"><span></span><button class="btn" id="gateEnter" type="button">Войти</button></div>
    </div>
  </div>
</div>

<!-- Контекстное меню для чата -->
<div class="chat-context-menu" id="chatContextMenu">
  <div class="chat-context-menu-item" id="contextReply">↩️ Ответить</div>
  <div class="chat-context-menu-item" id="contextEdit">✏️ Редактировать</div>
  <div class="chat-context-menu-item danger" id="contextDelete">🗑️ Удалить</div>
</div>

<script type="module">
  window.isOverlayHotkeys = new URLSearchParams(location.search).get('overlay')==='1';
  /* ==== FIREBASE ==== */
  const firebaseConfig = {
    apiKey: "AIzaSyAcrLDWHWA_diaVHQwtFUeWqq3WAzMYBnc",
    authDomain: "dpgames-66d73.firebaseapp.com",
    databaseURL: "https://dpgames-66d73-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "dpgames-66d73",
    storageBucket: "dpgames-66d73.firebasestorage.app",
    messagingSenderId: "734650657253",
    appId: "1:734650657253:web:6c98ad8e72a4156e7be70c",
    measurementId: "G-JBK5DRBTXN"
  };

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getDatabase, ref, onValue, set, remove, push, update, child, query, orderByChild, limitToLast,serverTimestamp, onChildAdded, onChildRemoved, get } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";
  import { getAuth, signInAnonymously, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

  const FIXED_VIEW = "https://vdo.ninja/?view=DepressivePasties";
  const SESSION_KEY = "DepressivePasties";

  const $ = (s)=>document.querySelector(s);

  // header controls
  const toolToggle=$('#toolToggle'), toolErase=$('#toolErase'), toolClear=$('#toolClear');
  const reactionsBar=$('#reactionsBar'); 
  reactionsBar.querySelectorAll('button').forEach(b=>{
    b.addEventListener('click', ()=>{
      // Анимация при клике
      b.classList.add('reaction-clicked');
      setTimeout(()=> b.classList.remove('reaction-clicked'), 400);
      
      // Определяем тип реакции
      const type = b.dataset.reactionType || 'emoji';
      if (type === 'png') {
        const src = b.dataset.reactionSrc;
        const key = b.dataset.reactionKey;
        sendReaction({ type: 'png', src, key }); // Отправляем объект для PNG
      } else {
        sendReaction(b.dataset.emo || b.textContent); // Старый код для эмодзи
      }
    });
  });


  
  
  // Hotkeys for reactions (host too)
  // Overlay (?overlay=1): Alt+QWETYASDFGZXCVB (15 кнопок, БЕЗ R для Nvidia!)
  // Browser: Numpad1..7 (оставляем как было)
  window.addEventListener('keydown', (e)=>{
    if (['INPUT','TEXTAREA'].includes((document.activeElement||{}).tagName)) return;
    if (e.repeat) return;

    let idx = undefined;
    if (window.isOverlayHotkeys){
      if (!e.altKey || e.ctrlKey || e.metaKey) return;
      // УДОБНАЯ РАСКЛАДКА БЕЗ R: Alt+QWETYASDFGZXCVB + UIO (18 кнопок)
      const mapOverlay = {
        'KeyQ': 0,  // 👍
        'KeyW': 1,  // 👎
        'KeyE': 2,  // ❤️
        'KeyT': 3,  // 😂 (пропускаем R для Nvidia!)
        'KeyY': 4,  // 😮
        'KeyA': 5,  // 😢
        'KeyS': 6,  // 🔥
        'KeyD': 7,  // 🤡
        'KeyF': 8,  // 🤬
        'KeyG': 9,  // 🍷
        'KeyZ': 10, // 🧐
        'KeyX': 11, // 💃
        'KeyC': 12, // 🚩
        'KeyV': 13, // 🤷‍♂️
        'KeyB': 14, // 🙄
        'KeyU': 15, // 16-я эмодзи
        'KeyI': 16, // 17-я эмодзи
        'KeyO': 17, // 18-я эмодзи
      };
      idx = mapOverlay[e.code];
    } else {
      // Browser: Numpad 1..7 без модификаторов
      if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) return;
      const mapBrowser = {
        'Numpad1': 0,
        'Numpad2': 1,
        'Numpad3': 2,
        'Numpad4': 3,
        'Numpad5': 4,
        'Numpad6': 5,
        'Numpad7': 6,
      };
      idx = mapBrowser[e.code];
    }

    if (idx !== undefined){
      const btns = reactionsBar.querySelectorAll('button');
      if (btns[idx]){
        const b = btns[idx];
        b.classList.add('reaction-clicked');
        setTimeout(()=> b.classList.remove('reaction-clicked'), 300);
        sendReaction(b.dataset.emo||b.textContent);
        e.preventDefault();
      }
    }
  });
  const logoutBtn=$('#logout');
  const toggleSelfClusters=$('#toggleSelfClusters');
  const $statusText=$('#status-text'), $dotAuth=$('#dot-auth');

  // footer admin controls
  const btnDeleteVotes=$('#btnDeleteVotes');

  // cinema controls (browser only; overlay keeps its own Alt+F for reactions)
  const btnCinema = $('#btnCinema');

  function setCinemaUI(on){
    document.body.classList.toggle('cinema', !!on);
    if (btnCinema){
      btnCinema.textContent = on ? 'Exit Fullscreen' : 'Fullscreen';
    }
  }
  function toggleCinemaUI(){ setCinemaUI(!document.body.classList.contains('cinema')); }

  if (btnCinema){
    btnCinema.addEventListener('click', ()=>{
      if (window.isOverlayHotkeys) return;
      toggleCinemaUI();
    });
  }

  // Hotkey: Alt+F (NOT for overlay)
  window.addEventListener('keydown', (e)=>{
    if (window.isOverlayHotkeys) return;
    if (['INPUT','TEXTAREA'].includes((document.activeElement||{}).tagName)) return;
    if (e.repeat) return;
    if (e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey && e.code === 'KeyF'){
      toggleCinemaUI();
      e.preventDefault();
    }
  });


  // canvases / layers
  const canvas=$('#overlay'), ctx=canvas.getContext('2d');
  const fxLayer = $('#fx-layer');
  const $player=$('#player');

  // gate fields
  const gate=$('#gate'), gateName=$('#gateName'), gateColor=$('#gateColor'), gatePin=$('#gatePin'), gateEnter=$('#gateEnter');
  const gateCard = document.getElementById('gateCard');
  const gateHint = document.getElementById('gateHint');
    const emojiSetup = document.querySelector('.emoji-setup-container');
    const emojiPreview = emojiSetup ? emojiSetup.querySelector('.preview-container') : null;
    if (emojiSetup) emojiSetup.classList.remove('open');
    if (emojiPreview) {
      emojiPreview.addEventListener('click', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        emojiSetup.classList.toggle('open');
      });
      document.addEventListener('click', (ev)=>{
        if (!emojiSetup) return;
        if (!emojiSetup.contains(ev.target)) emojiSetup.classList.remove('open');
      });
    }



  // chat
  const chatPanel=$('#chatPanel'); const chatToggle=$('#chatToggle'); const chatNotifications=$('#chatNotifications');
  const chatListSite=$('#chatListSite'), chatInput=$('#chatInput'), chatSend=$('#chatSend');
  const chatOverlay=$('#chatOverlay'), chatListOverlay=$('#chatListOverlay');
  const chatInputOverlay=$('#chatInputOverlay'), chatSendOverlay=$('#chatSendOverlay');
  const chatDragHandle=$('#chatDragHandle'); const chatBadge=$('#chatBadge');
  const chatContextMenu = $('#chatContextMenu');
  const contextReply = $('#contextReply');
  const contextEdit = $('#contextEdit');
  const contextDelete = $('#contextDelete');

  // === CHAT: dynamic font-size by WIDTH (resize:both, width-only scaling) ===
  // Требование: при растягивании чата по ширине текст внутри растёт/уменьшается; высота влияет только на видимость.
  const CHAT_FONT_BASE_W = 340;   // дизайн-ширина .chat-panel (см. CSS width:340px)
  const CHAT_FONT_BASE_PX = 14;   // базовый размер текста
  const CHAT_FONT_MIN_PX  = 12;
  const CHAT_FONT_MAX_PX  = 36;

  function __applyChatFontByWidth(){
    if (!chatPanel) return;
    // clientWidth = реальная ширина контента (без resize-угла/скролла)
    const w = Math.max(240, chatPanel.clientWidth || chatPanel.offsetWidth || CHAT_FONT_BASE_W);
    const scaled = CHAT_FONT_BASE_PX * (w / CHAT_FONT_BASE_W);
    const px = Math.max(CHAT_FONT_MIN_PX, Math.min(CHAT_FONT_MAX_PX, scaled));
    chatPanel.style.setProperty('--chat-font', (Math.round(px * 10) / 10) + 'px');
  }

  // 1) сразу при старте
  __applyChatFontByWidth();

  // 2) реакция на resize панели (drag-resize)
  if (window.ResizeObserver){
    const __chatRO = new ResizeObserver(() => __applyChatFontByWidth());
    __chatRO.observe(chatPanel);
  } else {
    // fallback (очень старые браузеры)
    window.addEventListener('resize', __applyChatFontByWidth);
    setInterval(__applyChatFontByWidth, 500);
  }


  // Reply state
  let replyToMessage = null;
  
  // Edit state
  let editingMessage = null;
  let replyIndicatorElement = null;

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth();

  const DEFAULT_COLOR = '#16c7b7';
  
  // ПРОВЕРКА URL ПАРАМЕТРА ?overlay=1 ДЛЯ АВТОМАТИЧЕСКОГО ВКЛЮЧЕНИЯ OVERLAY РЕЖИМА
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('overlay') === '1') {
    localStorage.setItem('cc_mode', 'overlay');
    console.log('🎬 Overlay mode activated via URL parameter');
    document.body.classList.add('overlay-mode'); // Добавляем класс для CSS
  }
  
  const state = {
    id: localStorage.getItem('cc_id') || crypto.randomUUID(),
    name: localStorage.getItem('cc_name') || '',
    color: localStorage.getItem('cc_color') || DEFAULT_COLOR,
    emoji: localStorage.getItem('cc_emoji') || '🐶',
    mode: localStorage.getItem('cc_mode') || 'watch',
    tool: localStorage.getItem('cc_tool') || 'vote',
    showClustersOnSite: (localStorage.getItem('cc_show_clusters') === '1' || localStorage.getItem('cc_show_clusters') === '1'),
    authed: false,
    points: new Map(),
    strokes: new Map(),
    presence: new Map(),
    tgIndex: new Map(),
    localChat: JSON.parse(localStorage.getItem('cc_chat_cache')||'[]'),
    notifications: localStorage.getItem('cc_notifications') !== 'false',
    unreadCount: 0,
    lastReadTs: Date.now(),
    currentStroke: null, // текущая рисуемая линия
  };

// === Cross-script emoji sync: fallback (non-module) picker -> module state ===
window.addEventListener('cc_emoji_changed', async (e) => {
  try {
    const emo = (e && e.detail && typeof e.detail.emoji !== 'undefined') ? String(e.detail.emoji) : '';
    state.emoji = emo;
    localStorage.setItem('cc_emoji', emo);

    // If already authed, update profile + my point immediately
    if (state.authed) {
      const uid = auth?.currentUser?.uid || state.id;

      // update my point
      const p = state.points.get(uid);
      if (p) {
        p.emoji = emo;
        state.points.set(uid, p);
        try { await set(ref(db, `${basePath}/points/${uid}`), p); } catch {}
      }

      // update my profile
      try {
        await update(ref(db), { [`${basePath}/users/${uid}/emoji`]: emo });
      } catch {}
    }
  } catch {}
});


  localStorage.setItem('cc_id', state.id);

  function saveState(){
    localStorage.setItem('cc_name',state.name);
    localStorage.setItem('cc_color',state.color);
    localStorage.setItem('cc_mode',state.mode);
    localStorage.setItem('cc_emoji', state.emoji || '');
    localStorage.setItem('cc_auth', 'true'); // Добавляем метку, что вход выполнен
  }

  /* ======= SIZE ======= */
  function sizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const w = Math.round(window.innerWidth * dpr);
    const h = Math.round(window.innerHeight * dpr);
    canvas.width=w; canvas.height=h;
    canvas.style.width=window.innerWidth+'px';
    canvas.style.height=window.innerHeight+'px';
  }
  sizeCanvas();
  let resizeTimer; window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer=setTimeout(sizeCanvas, 120); });

  let __videoRectCache = null;
  let __videoRectCacheAt = 0;

  function __computeVideoRect(){
    const dpr = window.devicePixelRatio||1;

    // В overlay режиме возвращаем размеры всего canvas (без iframe)
    if (isOverlayMode()) {
      const cw = canvas.clientWidth, ch = canvas.clientHeight;
      return { x:0, y:0, w:cw*dpr, h:ch*dpr, cssx:0, cssy:0, cssw:cw, cssh:ch };
    }

    // Для браузера: вычисляем актуальную область видео с учетом contain
    const videoWrap = document.getElementById('videoWrap');
    if (!videoWrap) {
      const cw = canvas.clientWidth, ch = canvas.clientHeight;
      return { x:0, y:0, w:cw*dpr, h:ch*dpr, cssx:0, cssy:0, cssw:cw, cssh:ch };
    }

    // Размеры videoWrap
    const wrapW = videoWrap.clientWidth;
    const wrapH = videoWrap.clientHeight;

    // Видео 16:9, вписываем в wrap с contain
    const videoAspect = 16/9;
    const wrapAspect = wrapW / wrapH;

    let videoW, videoH, videoX, videoY;

    if (wrapAspect > videoAspect) {
      // wrap шире чем видео - вписываем по высоте
      videoH = wrapH;
      videoW = videoH * videoAspect;
      videoX = (wrapW - videoW) / 2;
      videoY = 0;
    } else {
      // wrap выше чем видео - вписываем по ширине
      videoW = wrapW;
      videoH = videoW / videoAspect;
      videoX = 0;
      videoY = (wrapH - videoH) / 2;
    }

    // Координаты относительно canvas
    const wrapRect = videoWrap.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    const offsetX = wrapRect.left - canvasRect.left + videoX;
    const offsetY = wrapRect.top - canvasRect.top + videoY;

    return {
      x: offsetX*dpr,
      y: offsetY*dpr,
      w: videoW*dpr,
      h: videoH*dpr,
      cssx: offsetX,
      cssy: offsetY,
      cssw: videoW,
      cssh: videoH
    };
  }

  // Важно: videoRect() вызывается ОЧЕНЬ часто (в draw loop), поэтому:
  // - не дёргаем getBoundingClientRect каждый кадр
  // - обновляем кэш не чаще, чем раз в ~120мс (и при resize/scroll)
  function videoRect(force=false){
    const now = performance.now();
    if (!force && __videoRectCache && (now - __videoRectCacheAt) < 120) return __videoRectCache;
    __videoRectCacheAt = now;
    __videoRectCache = __computeVideoRect();
    return __videoRectCache;
  }

  window.addEventListener('scroll', ()=>{ __videoRectCacheAt = 0; }, {passive:true});
  window.addEventListener('resize', ()=>{ __videoRectCacheAt = 0; });
  function normFromEvent(evt){
    const rect = canvas.getBoundingClientRect();
    const px = (evt.touches? evt.touches[0].clientX: evt.clientX) - rect.left;
    const py = (evt.touches? evt.touches[0].clientY: evt.clientY) - rect.top;
    const r = videoRect();
    const cx = Math.min(Math.max(px, r.cssx), r.cssx + r.cssw);
    const cy = Math.min(Math.max(py, r.cssy), r.cssy + r.cssh);
    const nx = (cx - r.cssx) / r.cssw; const ny = (cy - r.cssy) / r.cssh;
    return {x:nx,y:ny};
  }
  function pxFromNorm(nx, ny){
    const r=videoRect(); const dpr=window.devicePixelRatio||1;
    return { x:(r.x + nx*r.w), y:(r.y + ny*r.h), r };
  }

  const basePath   = `sessions/${SESSION_KEY}`;
  const pointsRoot = ref(db, `${basePath}/points`);
  const strokesRoot= ref(db, `${basePath}/strokes`);
  const presenceRootRef = ref(db, `${basePath}/presence`);
  const chatRoot   = ref(db, `${basePath}/chat`);
  const reactsRoot = ref(db, `${basePath}/reactions`);
  const ratModeRef = ref(db, `${basePath}/rat_mode`);  // Флаг RAT режима
  const tgLinksRoot = ref(db, `${basePath}/telegram_links`);
  // Telegram links index: tgUserId -> siteUserId (нужно для toast-ов от Telegram)
  onValue(tgLinksRoot, (snap)=>{
    try{
      const v = snap.val() || {};
      const m = new Map();
      for (const [siteUid, rec] of Object.entries(v)){
        const tgId = rec && (rec.tgUserId ?? rec.telegramUserId);
        if (tgId != null) m.set(String(tgId), siteUid);
      }
      state.tgIndex = m;
    }catch(e){ console.warn('tgLinks index failed', e); }
  });



  /* ======= PRESENCE ======= */
// lastActive должен отражать РЕАЛЬНУЮ активность (клики/клавиши), а не heartbeat.
// heartbeat нужен только чтобы держать "онлайн" и ts свежим.
let __ccLastActiveLocal = Date.now();
let __ccLastActivePush = 0;

function __ccIsHidden(){ return document.hidden || document.visibilityState === 'hidden'; }

async function __ccWritePresence(partial){
  if (!auth.currentUser) return;
  const uid = auth.currentUser.uid;
  try{ await update(ref(db, `${basePath}/presence/${uid}`), partial); }catch{}
}

async function __ccWritePoint(partial){
  if (!auth.currentUser) return;
  const uid = auth.currentUser.uid;
  try{ await update(ref(db, `${basePath}/points/${uid}`), partial); }catch{}
}

async function __ccMarkActive(force=false){
  const now = Date.now();
  __ccLastActiveLocal = now;
  // Дребезг: не пушим lastActive чаще чем раз в 4 секунды
  if (!force && (now - __ccLastActivePush) < 4000) return;
  __ccLastActivePush = now;
  await __ccWritePresence({ state: 'online', lastActive: now });
  await __ccWritePoint({ lastActive: now });
}

// Activity signals
['pointerdown','keydown','wheel','touchstart'].forEach(evt=>{
  window.addEventListener(evt, ()=>__ccMarkActive(false), {passive:true});
});

document.addEventListener('visibilitychange', ()=>{
  if (__ccIsHidden()){
    __ccWritePresence({ state:'away', ts: Date.now() });
  }else{
    __ccMarkActive(true);
    __ccWritePresence({ state:'online', ts: Date.now() });
  }
});

async function heartbeat(){
  if (!auth.currentUser) return;
  const uid = auth.currentUser.uid;
  const nowTs = Date.now();
  const nm = getDisplayName(state) || 'Гость';
  // heartbeat НЕ трогает lastActive
  await __ccWritePresence({
    id: uid,
    name: nm,
    color: state.color,
    emoji: (state.emoji||''),
    ts: nowTs,
    state: __ccIsHidden() ? 'away' : 'online'
  });
  // точки обновляем минимально, чтобы цвет/имя/эмодзи синхрились, но lastActive не трогаем
  await __ccWritePoint({ color: state.color, name: nm, emoji: (state.emoji||'') });
}
setInterval(heartbeat, 8000);

// onDisconnect: помечаем оффлайн (насколько это возможно в RTDB)
(async ()=>{
  try{
    const uid = auth.currentUser?.uid;
    if (!uid) return;
    const pRef = ref(db, `${basePath}/presence/${uid}`);
    onDisconnect(pRef).update({ state:'offline', ts: Date.now() });
  }catch{}
})();

  /* ======= TELEGRAM LINKS INDEX (tgUserId -> uid) ======= */
  onValue(tgLinksRoot, (snap)=>{
    const all = snap.val() || {};
    const idx = new Map();
    for (const [k,info] of Object.entries(all)){
      // Support both schemas:
      // A) telegram_links/<uid> = { tgUserId, ... }
      // B) telegram_links/<tgUserId> = { uid, ... }
      const v = info || {};
      const tg = v.tgUserId || v.telegramUserId || v.tg_user_id || v.telegram_id || v.userId || v.telegramId || v.tgId;
      const uid = v.uid || v.userUID || v.userUid || v.siteUid || v.siteUID;
      const keyLooksLikeTg = /^\d+$/.test(String(k));
      if (keyLooksLikeTg && uid){
        idx.set(String(k), String(uid));
      } else if (tg){
        idx.set(String(tg), String(k));
      }
    }
    state.tgIndex = idx;
  });


  let __ccPrevOnline = new Set();
  let __ccPresenceInit = false;

  onValue(presenceRootRef, async (snap)=>{
    const val = snap.val() || {};
    const now = Date.now();

    const next = new Map();
    for (const [uid,p] of Object.entries(val)){
      // keep all entries; determine online/offline by ts/state later
      next.set(uid, p || {});
    }

    // Join toast in overlay: only after initial load, only when someone APPEARS online,
    // don't announce yourself, and anti-spam per user.
    if (__ccPresenceInit && isOverlayMode()){
      const me = auth.currentUser?.uid;
      const now = Date.now();
      window.__ccJoinToastAt = window.__ccJoinToastAt || new Map();

      const onlineNow = new Set();
      const appeared = [];

      for (const [uid,pRaw] of next.entries()){
        const p = pRaw || {};
        const ts = Number(p.ts || 0);
        const isFresh = ts > 0 && (now - ts) <= 12000;
        const st = p.state || 'online';
        const isOnline = isFresh && st !== 'offline';
        if (isOnline) onlineNow.add(uid);

        if (uid === me) continue;
        if (isOnline && !__ccPrevOnline.has(uid)){
          // антиспам: не чаще 1 раза в 5 минут на uid
          const last = window.__ccJoinToastAt.get(uid) || 0;
          if (now - last < 5*60*1000) continue;
          window.__ccJoinToastAt.set(uid, now);
          appeared.push(uid);
        }
      }

      // подтягиваем имя из профиля/points, если presence ещё не успел его принести (первый заход)
      for (const uid of appeared){
        const p = next.get(uid) || {};
        let nm = (p && p.name) ? String(p.name) : '';
        if (!nm || nm === 'Чужой' || nm === 'Гость'){
          try{
            const snapU = await get(ref(db, `${basePath}/points/${uid}`));
            const v = snapU.val();
            if (v && v.name) nm = String(v.name);
          }catch{}
          if (!nm){
            try{
              const snapU2 = await get(ref(db, `${basePath}/users/${uid}`));
              const v2 = snapU2.val();
              if (v2 && (v2.displayName || v2.name)) nm = String(v2.displayName || v2.name);
            }catch{}
          }
        }
        if (!nm){
          // иногда запись профиля приходит с задержкой
          try{ await new Promise(r=>setTimeout(r, 300)); }catch{}
          try{
            const snapU3 = await get(ref(db, `${basePath}/points/${uid}`));
            const v3 = snapU3.val();
            if (v3 && v3.name) nm = String(v3.name);
          }catch{}
        }
        if (!nm) nm = 'кто-то';
        try{
          console.log('[JOIN TOAST] show', { uid, name: nm, ts: p.ts||0, state: p.state||'online', color: p.color||'#16c7b7', emoji: p.emoji||'⭕', now: Date.now(), prevOnline: (__ccPrevOnline && __ccPrevOnline.has ? __ccPrevOnline.has(uid) : undefined) });
        }catch(e){}
        showOverlayToast({ uid, color: p.color || '#16c7b7', emoji: p.emoji || '⭕', text: `У нас тут ${nm}` });
      }

      __ccPrevOnline = onlineNow;
    }
state.presence.clear();
    for (const [uid,p] of next.entries()){
      state.presence.set(uid,p);
    }

    // keep a rolling set of who is ONLINE right now (fresh ts)
    __ccPrevOnline = (()=>{ 
      const s = new Set(); 
      const now = Date.now();
      for (const [uid,pRaw] of next.entries()){
        const p = pRaw || {};
        const ts = Number(p.ts || 0);
        const isFresh = ts > 0 && (now - ts) <= 12000;
        const st = p.state || 'online';
        if (isFresh && st !== 'offline') s.add(uid);
      }
      return s;
    })();
    __ccPresenceInit = true;
  });

  /* ======= DATA LISTENERS ======= */

  let userEmojis = []; // Сюда загрузим твои кастомные штуки

  function setupEmojiListener(uid) {
    const emojiRef = ref(db, `${basePath}/users/${uid}/settings/emojis`);
    onValue(emojiRef, (snap) => {
      const val = snap.val();
      if (val && Array.isArray(val)) {
        userEmojis = val;
        applyUserEmojis(); // Красим кнопки
      }
    });
  }

  // Функция, которая берет массив и "засовывает" эмодзи в твои кнопки
  function applyUserEmojis() {
    userEmojis.forEach((emo, i) => {
      const btn = document.getElementById(`emoBtn_${i}`);
      if (btn) {
        btn.innerHTML = emo;
        btn.setAttribute('data-emo', emo);
      }
    });
    // Если есть панель оверлея, её тоже обновим
    if (typeof renderOverlayEmojis === 'function') renderOverlayEmojis();
  }


  onValue(pointsRoot, (snap)=>{
    const val=snap.val()||{}; 
    state.points.clear(); 
    for (const [id,p] of Object.entries(val)) state.points.set(id,p);
  });
  onValue(strokesRoot, (snap)=>{
    const val = snap.val() || {};
    state.strokes.clear();
    for (const [k,s] of Object.entries(val)) state.strokes.set(k,s);

    // PERF: штрихи не надо пересобирать каждый кадр — пересобираем только при изменениях
    state._strokesDirty = true;
    state._strokesSortedCache = null;
  });
// === CHAT — стабильная подписка по серверному времени ===
const msgs = [];               // единый массив сообщений
let lastReadT = state.lastReadTs || 0; // для бейджика

const getT = (m)=> (m.t ?? m.ts ?? 0); // совместимость со старым полем

(function setupChat(){
  // ВАЖНО: в rules должно быть .indexOn: ["t"]
  const q = query(chatRoot, orderByChild('t'), limitToLast(100));

  onChildAdded(q, (snap)=>{
    const m = { key: snap.key, ...snap.val() };

    // дедуп
    const i = msgs.findIndex(x=>x.key===m.key);
    if (i>=0) msgs[i]=m; else msgs.push(m);

    // сортировка по (t, key)
    msgs.sort((a,b)=> getT(a) - getT(b) || (a.key < b.key ? -1 : 1));

    // бейджик "непрочитанных" — только сообщения от других и новее порога
    const isForeign = (m.uid !== (auth.currentUser?.uid || state.id));
    if (isForeign && getT(m) > lastReadT){
      if (chatCollapsed) state.unreadCount += 1;
      lastReadT = getT(m);
      state.lastReadTs = lastReadT;
      updateUnreadBadge();
      playNotificationSound();
      vibrate();
      if (isOverlayMode()) showOverlayToast(m);
    }

    // рендер
    const stickSite = nearBottom(chatListSite);
    const stickOv   = nearBottom(chatListOverlay);
    renderChat(msgs);
    if (stickSite) chatListSite.scrollTop = chatListSite.scrollHeight;
    if (stickOv)   chatListOverlay.scrollTop = chatListOverlay.scrollHeight;

    // локальный кэш (без смешивания с удалёнными!)
    state.localChat = msgs.slice(-100);
    localStorage.setItem('cc_chat_cache', JSON.stringify(state.localChat));
  });
  
  // Слушаем удаление сообщений
  onChildRemoved(q, (snap)=>{
    const removedKey = snap.key;
    const index = msgs.findIndex(m => m.key === removedKey);
    if (index >= 0) {
      msgs.splice(index, 1);
      renderChat(msgs);
      state.localChat = msgs.slice(-100);
      localStorage.setItem('cc_chat_cache', JSON.stringify(state.localChat));
    }
  });
})();

function nearBottom(el, pad=60){
  return el.scrollHeight - el.scrollTop - el.clientHeight < pad;
}


  /* ======= REACTIONS ======= */
// импортируй serverTimestamp в одном блоке импортов
// ... limitToLast, onChildAdded, serverTimestamp } from ".../firebase-database.js";


let _lastReactionAt = 0;

async function sendReaction(reaction) {
  try {
    // 0) доступ есть?
    if (!auth?.currentUser) {
      console.warn('[rx] blocked: no auth');
      return;
    }

    // 1) антиспам
    const now = Date.now();
    if (now - _lastReactionAt < 350) {
      console.log('[rx] throttled');
      return;
    }
    _lastReactionAt = now;

    // 2) данные под правила
    const color = (state?.color && String(state.color).trim()) || '#16c7b7';
    const item = {
      uid: auth.currentUser.uid,
      color,                 // обязателен и не пустой
      t: serverTimestamp(),  // сортировка по серверному времени
      id: crypto.randomUUID()
    };

    // Если реакция - PNG (объект)
    if (typeof reaction === 'object' && reaction.type === 'png') {
      item.type = 'png';
      item.src = reaction.src; // Путь к PNG
      item.key = reaction.key; // Ключевое слово (для отладки)
    } else {
      // Обычная эмодзи (строка)
      item.emoji = reaction;
      item.emo = reaction; // для совместимости
    }

    // 3) пуш в новый ключ
    const db = getDatabase();
    const key = push(reactsRoot).key;
    console.log('[rx] push', key, item);
    await update(child(reactsRoot, key), item);

    console.log('[rx] ok', key);
  } catch (e) {
    console.error('Failed to send reaction to Firebase:', e);
  }
}

// === REACTIONS — стабильный стрим + логи ===
if (!window.__reactionsBound) {
  window.__reactionsBound = true;

  console.log('[rx] binding reactions stream on', `${basePath}/reactions`);

  // A) точечный поток onChildAdded — каждый новый push по одному
  // ОПТИМИЗАЦИЯ: НЕ показываем старые реакции при подключении
  const startTime = Date.now();
  const tailSize = 10; // Или твой значение, если другое
  const qA = query(reactsRoot, orderByChild('t'), limitToLast(tailSize));
  onChildAdded(qA, (snapshot) => {
    const it = snapshot.val();
    const key = snapshot.key;
    console.log('[rx] childAdded', key, JSON.stringify(it)); // Дебаг с полным объектом

    // Игнорируем старые реакции (до подключения)
    if (it.t < startTime - 1000) {
      console.log('[rx] skipped old reaction', key);
      return;
    }

    const isOurReaction = (it.uid === (auth.currentUser?.uid || state.id));
    const shouldShow = isOverlayMode() || !isOurReaction;
    if (shouldShow && typeof spawnEmoji === 'function') {
      spawnEmoji(it);
    }
  });

  // B) Диагностика: размер хвоста (видим, что подписка реально живёт)
  const qB = query(reactsRoot, orderByChild('t'), limitToLast(5));
  onValue(qB, (snap) => {
    let cnt = 0; snap.forEach(()=>cnt++);
    console.log('[rx] tail size', cnt);
  });
}


  /* ======= AUTH GATE + АВТОЛОГИН ======= */
  function setBlur(on){ document.querySelector('.app').classList.toggle('blur-wrap', on); }
  function isOverlayMode(){ return (localStorage.getItem('cc_mode')||'watch')==='overlay'; }

  // АВТОЛОГИН ДЛЯ OVERLAY РЕЖИМА
  const AUTO_LOGIN_NAME = 'Лёха';
  const AUTO_LOGIN_COLOR = '#1e40af'; // насыщенно синий
  const AUTO_LOGIN_PIN = '1111';

  gateEnter.addEventListener('click', doGateLogin);
  gatePin.addEventListener('keydown', e=>{ if(e.key==='Enter') doGateLogin(); });

  // Функция загрузки состояния и проверки автологина
  function checkAutoLogin() {
    const savedName = localStorage.getItem('cc_name');
    const isAuth = localStorage.getItem('cc_auth') === 'true';

    // Если человек нажал "Выйти", cc_auth будет удален, и мы просто стоим на месте
    if (!isAuth || !savedName) {
      console.log('No active session found.');
      gate.classList.remove('hidden');
      setBlur(true);
      return; 
    }

    // Если сессия есть - заходим мгновенно
    gate.classList.add('hidden'); 
    setBlur(false);
    
    state.name = savedName;
    state.color = localStorage.getItem('cc_color') || '#16c7b7';
    if (window.__neoApplyAccent) window.__neoApplyAccent(state.color);
    
    setTimeout(() => {
      // Подставляем ПИН только для системного входа
      gatePin.value = '1111'; 
      doGateLogin();
    }, 10);
  }

  // Запускаем проверку сразу
  checkAutoLogin();

  async function doGateLogin() {
    const pin = gatePin.value.trim();
    const inputName = document.getElementById('gateName').value.trim() || 'Чужой';
    const inputColor = gateColor.value;

    if (pin !== '1111') {
      gateHint.textContent = 'Неверный ПИН';
      gateHint.classList.add('show');
      gatePin.classList.add('error');
      gateCard.classList.remove('error');
      requestAnimationFrame(() => gateCard.classList.add('error'));
      gatePin.select();
      return;
    }

    // Быстрая локальная проверка (если бан уже был в этой сессии)
    if (localStorage.getItem('cc_banned') === 'true') {
      document.body.innerHTML = '<h1 style="color:white; text-align:center; margin-top:20%;">⚰️ ТЫ МЕРТВ И ИЗГНАН ⚰️</h1>';
      return;
    }

    try {
      console.log("LOG: Начинаем вход...");

      // 1. СНАЧАЛА АВТОРИЗАЦИЯ
      // Теперь база будет знать, что мы "свои", и даст прочитать список банов
      await signInAnonymously(auth);
      const uid = auth.currentUser.uid;
      console.log("LOG: Авторизация успешна, UID:", uid);

      // 2. ПОЛУЧАЕМ IP
      let userIP = null;
      try {
        const ipRes = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipRes.json();
        userIP = ipData.ip;
        console.log("LOG: Ваш IP:", userIP);
      } catch (e) { console.warn("Не удалось получить IP"); }

      // 3. ПРОВЕРКА ГЛОБАЛЬНОГО БАНА ПО IP
      if (userIP) {
        const ipKey = userIP.replaceAll('.', '_');
        // Пытаемся прочитать бан. Теперь Permission Denied быть не должно!
        const banRef = ref(db, `${basePath}/banned_ips/${ipKey}`);
        const banSnap = await get(banRef);
        
        if (banSnap.exists()) {
          const banData = banSnap.val();
          if (Date.now() < banData.bannedUntil) {
            localStorage.setItem('cc_banned', 'true');
            alert(`ВАШ IP ЗАБЛОКИРОВАН. ⚰️`);
            await signOut(auth); // Выходим, раз бан подтвержден
            location.reload();
            return;
          }
        }
      }

      // 4. ПОЛУЧЕНИЕ ДАННЫХ ПРОФИЛЯ
      const userRef = ref(db, `${basePath}/users/${uid}`);
      const userSnap = await get(userRef);
      const userData = userSnap.val();

      // Синхронизируем состояние
      if (userData) {
        state.name = (inputName !== 'Чужой') ? inputName : (userData.name || 'Чужой');
        state.createdAt = userData.createdAt;
        state.activity = userData.activity || {};
        state.color = userData.color || inputColor;
        if (window.__neoApplyAccent) window.__neoApplyAccent(state.color);
      } else {
        state.name = inputName;
        state.color = inputColor;
        if (window.__neoApplyAccent) window.__neoApplyAccent(state.color);
        state.createdAt = Date.now();
        state.activity = {};
      }

      // 5. ПРОВЕРКА НА 4 ЧЕРЕПА (СМЕРТЬ)
      if (typeof getSkullLevel === 'function' && getSkullLevel(state) >= 4) {
        localStorage.setItem('cc_banned', 'true');
        
        if (userIP) {
          const ipKey = userIP.replaceAll('.', '_');
          await set(ref(db, `${basePath}/banned_ips/${ipKey}`), {
            uid: uid,
            name: state.name,
            bannedAt: serverTimestamp(),
            bannedUntil: Date.now() + (7 * 24 * 60 * 60 * 1000)
          });
        }
        
        alert("ТЫ МЕРТВ. Вход воспрещен. ⚰️");
        await signOut(auth);
        location.reload();
        return;
      }

      // 6. ОБНОВЛЕНИЕ БАЗЫ
      const now = new Date();
      const dateKey = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      
      const updates = {
        lastSeen: serverTimestamp(),
        lastIP: userIP || 'unknown',
        name: state.name,
        color: state.color,
      emoji: state.emoji || '',
        [`activity/${dateKey}`]: serverTimestamp()
      };
      if (!userData || !userData.createdAt) updates.createdAt = serverTimestamp();

      await update(userRef, updates);

      // 7. ФИНАЛИЗАЦИЯ
      saveState();
      state.authed = true;
      gate.classList.add('hidden');
      setBlur(false);

      if (window.$statusText) $statusText.textContent = 'Онлайн';
      console.log("FINAL STATE CHECK:", state.name);

      if (typeof initVideo === 'function') initVideo();
      if (typeof heartbeat === 'function') heartbeat();

    } catch (e) {
      console.error('Ошибка входа:', e);
      // Если всё еще пишет Permission Denied, значит нужно проверить правила в консоли Firebase
      if (e.message.toLowerCase().includes('permission denied')) {
        alert("Ошибка доступа к базе. Проверь Rules в консоли Firebase.");
      } else {
        alert('Ошибка: ' + e.message);
      }
    }
  }



  // LOGOUT
  logoutBtn.addEventListener('click', async ()=>{
    console.log('Logging out and clearing session...');
    // Удаляем свою морду (кластер) сразу, чтобы не висела как зомби
    try{
      const uid = auth.currentUser?.uid || state.id;
      if (uid) {
        await remove(ref(db, `${basePath}/points/${uid}`));
        await remove(ref(db, `${basePath}/presence/${uid}`));
      }
    }catch(e){}
    try { await signOut(auth); } catch(e) {}

    // ПОЛНАЯ ОЧИСТКА: удаляем всё, что связано с авторизацией
    localStorage.removeItem('cc_auth');
    localStorage.removeItem('cc_name');
    localStorage.removeItem('cc_color');

    state.authed = false;
    state.name = '';
    
    // Сбрасываем поля в интерфейсе, чтобы они были пустыми
    document.getElementById('gateName').value = '';
    gatePin.value = '';
    gateColor.value = '#16c7b7';

    $statusText.textContent = 'Оффлайн';
    $dotAuth.classList.remove('ok');
    $dotAuth.classList.add('warn');

    gate.classList.remove('hidden'); 
    setBlur(true);
  });

  function syncSelfClustersBtn(){
    if (!toggleSelfClusters) return;
    const on = !!state.showClustersOnSite;
    toggleSelfClusters.textContent = on ? 'Голоса: видны' : 'Голоса: скрыты';
    toggleSelfClusters.classList.toggle('active', on);
  }
  if (toggleSelfClusters){
    // кнопка нужна только в режиме просмотра (не overlay)
    if (isOverlayMode && isOverlayMode()) toggleSelfClusters.style.display = 'none';
    toggleSelfClusters.addEventListener('click', ()=>{
      state.showClustersOnSite = !state.showClustersOnSite;
      localStorage.setItem('cc_show_clusters', state.showClustersOnSite ? '1' : '0');
      syncSelfClustersBtn();
    });
    syncSelfClustersBtn();
  }


  // при загрузке всё размыто
  setBlur(true);

  function initVideo(){
    const url = new URL(FIXED_VIEW);
    if(!url.searchParams.get('cleanoutput')) url.searchParams.set('cleanoutput','1');
    if(!url.searchParams.get('stats')) url.searchParams.set('stats','0');
    if (!isOverlayMode()) $player.src = url.toString();
    else $player.classList.add('hidden');
  }
  $statusText.textContent='Оффлайн'; $dotAuth.classList.add('warn');

  onAuthStateChanged(auth, (user)=>{
    if (user) { state.authed = true; $dotAuth.classList.remove('warn'); $dotAuth.classList.add('ok'); $statusText.textContent='Онлайн'; heartbeat();setupEmojiListener(user.uid); }
    else { state.authed = false; $dotAuth.classList.remove('ok'); $dotAuth.classList.add('warn'); $statusText.textContent='Оффлайн'; }
  });

  /* ======= TOOLS ======= */
  function updateToolDisplay() {
    // Обновляем внешний вид кнопок в зависимости от активного инструмента
    if (state.tool === 'vote') {
      // Режим голосования
      toolToggle.textContent = 'Рисовать';
      toolToggle.classList.remove('btn');
      toolToggle.classList.add('btn', 'ghost', 'small');
      
      toolErase.classList.remove('btn');
      toolErase.classList.add('btn', 'ghost', 'small');
    } else if (state.tool === 'draw') {
      // Режим рисования
      toolToggle.textContent = 'Голосовать';
      toolToggle.classList.remove('ghost');
      toolToggle.classList.add('btn', 'small');
      
      toolErase.classList.remove('btn');
      toolErase.classList.add('btn', 'ghost', 'small');
    } else if (state.tool === 'erase') {
      // Режим ластика
      toolToggle.textContent = 'Голосовать';
      toolToggle.classList.remove('btn');
      toolToggle.classList.add('btn', 'ghost', 'small');
      
      toolErase.classList.remove('ghost');
      toolErase.classList.add('btn', 'small');
    }
  }
  
  function setTool(t){
    state.tool=t; saveState();
    updateToolDisplay();
    
    // Обновляем слайдер и диапазон при смене инструмента
    if (t === 'draw') {
      brushSizeSlider.min = MIN_WIDTH;
      brushSizeSlider.max = MAX_PEN_WIDTH;
      brushSizeSlider.value = PEN_WIDTH;
      brushSizeValue.textContent = PEN_WIDTH + 'px';
    } else if (t === 'erase') {
      brushSizeSlider.min = MIN_WIDTH;
      brushSizeSlider.max = MAX_ERASE_WIDTH;
      brushSizeSlider.value = ERASE_WIDTH;
      brushSizeValue.textContent = ERASE_WIDTH + 'px';
    }
  }
  toolToggle.addEventListener('click', ()=>{
    if (state.tool==='vote') {
      setTool('draw');
    } else {
      setTool('vote');
    }
  });
  toolErase.addEventListener('click', ()=> {
    if (state.tool === 'erase') {
      // Если ластик уже активен, возвращаемся к рисованию
      setTool('draw');
    } else {
      // Иначе включаем ластик
      setTool('erase');
    }
  });
  toolClear.addEventListener('click', async ()=>{
    if (!auth.currentUser) return;
    if (confirm('Очистить все рисунки?')) await remove(strokesRoot);
  });

  /* ======= ADMIN CONTROLS (FOOTER) ======= */

  // Кнопка "Удалить голоса"
  if (btnDeleteVotes) {
    btnDeleteVotes.addEventListener('click', async ()=>{
      if (!auth.currentUser) { alert('Сначала войдите'); return; }
      const password = prompt('Введите пароль для удаления голосов:');
      if (password !== '0000') { if (password !== null) alert('Неверный пароль'); return; }
      if (!confirm('Удалить ВСЕ голоса?')) return;
      try {
        await remove(pointsRoot);
        state.points.clear();
        alert('Все голоса удалены');
      } catch(e) {
        alert('Ошибка при удалении голосов');
      }
    });
  }

  /* ======= CHAT UI ======= */
  let chatCollapsed=false;
  
  // Звук уведомления (простой beep)
  function playNotificationSound(){
    if (!state.notifications) return;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.frequency.value = 800;
    oscillator.type = 'sine';
    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    oscillator.start(audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + 0.2);
  }
  
  // Вибрация на мобильных
  function vibrate(){
    if (!state.notifications) return;
    // Chrome blocks vibrate until user interacts — avoid console spam.
    if (!window.__ccUserInteracted) return;
    if (navigator.vibrate) navigator.vibrate(200);
  }

  // Mark first user interaction (for vibration/audio policies)
  (function(){
    if (window.__ccUserInteracted) return;
    window.__ccUserInteracted = false;
    const mark = ()=>{ window.__ccUserInteracted = true; cleanup(); };
    const cleanup = ()=>{
      window.removeEventListener('pointerdown', mark, true);
      window.removeEventListener('keydown', mark, true);
      window.removeEventListener('mousedown', mark, true);
      window.removeEventListener('touchstart', mark, true);
    };
    window.addEventListener('pointerdown', mark, true);
    window.addEventListener('mousedown', mark, true);
    window.addEventListener('touchstart', mark, true);
    window.addEventListener('keydown', mark, true);
  })()
  
  // Обновление счетчика
  function updateUnreadBadge(){
    if (state.unreadCount > 0 && chatCollapsed){
      chatBadge.textContent = state.unreadCount > 99 ? '99+' : state.unreadCount;
      chatBadge.classList.remove('hidden');
    } else {
      chatBadge.classList.add('hidden');
    }
  }
  
  // Кнопка уведомлений
  chatNotifications.addEventListener('click', ()=>{
    state.notifications = !state.notifications;
    localStorage.setItem('cc_notifications', state.notifications);
    chatNotifications.textContent = state.notifications ? '🔔' : '🔕';
    chatNotifications.style.opacity = state.notifications ? '1' : '0.5';
  });
  // Установим начальное состояние
  chatNotifications.textContent = state.notifications ? '🔔' : '🔕';
  chatNotifications.style.opacity = state.notifications ? '1' : '0.5';
  
  chatToggle.addEventListener('click', ()=>{
    // запоминаем размер до сворачивания, чтобы вернуть 1-в-1
    if (!chatCollapsed){
      const r = chatPanel.getBoundingClientRect();
      window.__chatPrevSize = { w: r.width, h: r.height, left: chatPanel.style.left, top: chatPanel.style.top };
    }

    chatCollapsed = !chatCollapsed;
    chatToggle.textContent = chatCollapsed ? 'Развернуть' : 'Свернуть';

    chatPanel.classList.toggle('collapsed', chatCollapsed);
    chatPanel.querySelector('.chat-body').classList.toggle('chat-hidden', chatCollapsed);
    chatPanel.querySelector('.chat-input').classList.toggle('chat-hidden', chatCollapsed);

    // При свёртывании: панель должна стать высотой своей шапки (chat-header)
    if (chatCollapsed) {
      const hdr = chatPanel.querySelector('.chat-header');
      const targetH = hdr ? hdr.getBoundingClientRect().height : 54;

      chatPanel.style.overflow = 'hidden';
      chatPanel.style.minHeight = '0px';
      chatPanel.style.maxHeight = Math.ceil(targetH) + 'px';
      chatPanel.style.height = Math.ceil(targetH) + 'px';
      chatPanel.style.resize = 'none';
    } else {
      // При разворачивании: возвращаем прошлую высоту, если была
      chatPanel.style.maxHeight = '65vh';
      chatPanel.style.overflow = '';
      chatPanel.style.minHeight = '200px';
      chatPanel.style.resize = 'both';

      const prev = window.__chatPrevSize;
      if (prev && prev.h) {
        chatPanel.style.height = Math.round(prev.h) + 'px';
        chatPanel.style.width  = Math.round(prev.w) + 'px';
      } else {
        chatPanel.style.height = '';
      }
    }

    // При разворачивании сбрасываем счетчик
    if (!chatCollapsed){
      state.unreadCount = 0;
      state.lastReadTs = Date.now();
      updateUnreadBadge();
    }
  });

  chatSend.addEventListener('click', sendChat);
  chatInput.addEventListener('keydown', e=>{ if(e.key==='Enter') sendChat(); });
  
  // Overlay-чат (также может отправлять сообщения)
  chatSendOverlay.addEventListener('click', sendChatOverlay);
  chatInputOverlay.addEventListener('keydown', e=>{ if(e.key==='Enter') sendChatOverlay(); });
// ===== Отправка в чат (сайт) =====
async function sendChat(){
  if (!state.authed) return;
  const txt = chatInput.value.trim(); 
  if (!txt) return;

  // Если редактируем сообщение
  if (editingMessage) {
    await saveEditedMessage(txt);
    return;
  }

  // Проверяем команду /rat
  if (txt === '/rat') {
    chatInput.value = '';
    await toggleRatMode();
    return;
  }


// Команда /art — локальный арт-режим (только для этого юзера). Команда НЕ отправляется в чат.
if (txt === '/art') {
  if (typeof chatInput !== 'undefined') chatInput.value = '';
  if (typeof chatInputOverlay !== 'undefined') chatInputOverlay.value = '';
  toggleArtMode();
  return;
}

// Команда /kick — локальный режим: клик по оффлайн-морде удаляет её из канваса. Команда НЕ отправляется в чат.
if (txt === '/kick') {
  if (typeof chatInput !== 'undefined') chatInput.value = '';
  if (typeof chatInputOverlay !== 'undefined') chatInputOverlay.value = '';
  state.kickMode = true;
  // подсказка только себе
  try { showToast('KICK: кликни по ЛЮБОЙ морде, чтобы убрать её'); } catch {}
  return;
}

// Команда /random — выбираем победителя среди самых больших кластеров. Команда НЕ отправляется в чат.
if (txt === '/random') {
  if (typeof chatInput !== 'undefined') chatInput.value = '';
  if (typeof chatInputOverlay !== 'undefined') chatInputOverlay.value = '';
  triggerRandomBroadcast();
  return;
}
  // --- ВНУТРИ ОБРАБОТЧИКА ОТПРАВКИ СООБЩЕНИЯ ---

  // 1. Команда объединения: /id_старый+id_новый
  // Команда слияния: /ID1 + ID2
  if (txt.startsWith('/') && txt.includes(' + ')) {
      // Команда слияния аккаунтов: /ID1 + ID2
      // Требование: итоговый профиль (имя/цвет/эмодзи) = у аккаунта с ПОЗЖЕЙ датой регистрации (createdAt больше),
      // независимо от порядка ввода.
      const cleanTxt = txt.substring(1);
      const [idAraw, idBraw] = cleanTxt.split('+').map(s => s.trim());
      const idA = idAraw;
      const idB = idBraw;

      if (typeof chatInput !== 'undefined') chatInput.value = '';

      (async ()=>{
        try{
          const refA = ref(db, `${basePath}/users/${idA}`);
          const refB = ref(db, `${basePath}/users/${idB}`);
          const snapA = await get(refA);
          const snapB = await get(refB);

          if (!snapA.exists() || !snapB.exists()){
            alert('Один из аккаунтов не найден в базе.');
            return;
          }

          const a = snapA.val() || {};
          const b = snapB.val() || {};

          
          const createdA = Number(a.createdAt || 0);
          const createdB = Number(b.createdAt || 0);

          // MERGE правило (v47):
          //  a) UID итогового аккаунта = СТАРЫЙ (ранний createdAt), чтобы совпадало с siteUserId в telegram_links
          //  b) Профиль (имя/цвет/морда=emoji) берём из НОВОГО (поздний createdAt)
          //  c) Настройки "панели эмодзи" (если они вообще есть в базе) сохраняем от СТАРОГО
          const oldId = (createdA <= createdB) ? idA : idB;
          const newId = (oldId === idA) ? idB : idA;

          const keepId = oldId; // остаётся
          const dropId = newId; // удаляется

          const oldData = (keepId === idA) ? a : b;
          const newData = (dropId === idA) ? a : b;

          const keepRef = ref(db, `${basePath}/users/${keepId}`);
          const dropRef = ref(db, `${basePath}/users/${dropId}`);

          // 1) Мержим активность
          const mergedActivity = {
            ...(oldData.activity || {}),
            ...(newData.activity || {})
          };

          // 2) createdAt сохраняем как самую раннюю (чтобы "возраст" не омолаживался)
          const earliestCreated = Math.min(
            Number(oldData.createdAt || Date.now()),
            Number(newData.createdAt || Date.now())
          );

          // 3) Профиль (имя/цвет/морда) берём из НОВОГО
          const profileName  = (newData.name || newData.displayName || oldData.name || oldData.displayName || 'User');
          const profileColor = (newData.color || oldData.color || '#16c7b7');
          const profileEmoji = (newData.emoji || oldData.emoji || '⭕');

          // 4) "Панель эмодзи" — сохраняем от СТАРОГО (если такое поле существует)
          const emojiPanelState =
            (oldData.emojiPanelState ?? oldData.emojiPanel ?? oldData.emojiPicker ?? oldData.emojiPanelPrefs ?? null);

          const patch = {
            activity: mergedActivity,
            createdAt: earliestCreated,
            mergedFrom: dropId,
            mergedAt: Date.now(),
            name: profileName,
            color: profileColor,
            emoji: profileEmoji
          };
          if (emojiPanelState != null) patch.emojiPanelState = emojiPanelState;

          await update(keepRef, patch);

          // Обновим points "победителя" профилем, координаты не трогаем
          try{
            await update(ref(db, `${basePath}/points/${keepId}`), {
              name: profileName,
              color: profileColor,
              emoji: profileEmoji
            });
          }catch{}

          // 5) Переносим telegram_links:
          // после merge запись должна лежать по ключу keepId и иметь siteUserId = keepId.
          try{
            const allLinksSnap = await get(ref(db, `${basePath}/telegram_links`));
            const allLinks = allLinksSnap.val() || {};
            let chosen = null;

            for (const [k, v0] of Object.entries(allLinks)){
              const v = v0 || {};
              const su = v.siteUserId || k;
              const related = (k === keepId) || (su === keepId) || (k === dropId) || (su === dropId);
              if (!related) continue;

              // предпочитаем запись с tgUserId
              if (!chosen) chosen = { key:k, val:v };
              else if ((chosen.val.tgUserId == null) && (v.tgUserId != null)) chosen = { key:k, val:v };
            }

            if (chosen && chosen.val){
              const finalVal = {
                ...chosen.val,
                siteUserId: keepId,
                siteName: profileName,
                siteColor: profileColor,
                migratedAt: Date.now()
              };
              await set(ref(db, `${basePath}/telegram_links/${keepId}`), finalVal);
            }

            // удаляем все прочие записи, которые указывают на keep/drop (кроме нового каноничного keepId)
            for (const [k, v0] of Object.entries(allLinks)){
              if (k === keepId) continue;
              const v = v0 || {};
              const su = v.siteUserId || k;
              const related = (k === keepId) || (su === keepId) || (k === dropId) || (su === dropId);
              if (related){
                try{ await remove(ref(db, `${basePath}/telegram_links/${k}`)); }catch{}
              }
            }
          }catch(e){ console.warn('merge telegram_links failed', e); }

          // 6) Удаляем points/presence "нового" аккаунта, чтобы не оставалась морда-призрак
          try{ await remove(ref(db, `${basePath}/points/${dropId}`)); }catch{}
          try{ await remove(ref(db, `${basePath}/presence/${dropId}`)); }catch{}

          // 7) Удаляем "новый" аккаунт
          await remove(dropRef);

          alert(`Слияние завершено! UID оставлен: ${keepId} (старый). Профиль взят из: ${dropId} (новый).`);
}catch(e){
          console.error(e);
          alert('Ошибка при слиянии. Смотри консоль.');
        }
      })();

      return;
  } // Чтобы сообщение не улетело в чат

// 2. Команда накопительного очерепнения с IP-баном: /id skull
  if (txt.startsWith('/') && txt.endsWith(' skull')) {
    chatInputOverlay.value = '';
    const targetId = txt.replace('/', '').replace(' skull', '').trim();
    
    if (targetId) {
      const userRef = ref(db, `${basePath}/users/${targetId}`);
      const snap = await get(userRef);
      
      if (!snap.exists()) {
        console.error("Пользователь не найден в базе");
        // no return here; handled by else
      } else {

      const data = snap.val();
      const activity = data.activity || {};
      let currentCreatedAt = data.createdAt || Date.now();

      let d = new Date();
      // 1. Находим ближайшую прошедшую (или текущую) субботу
      while (d.getDay() !== 6) { d.setDate(d.getDate() - 1); }

      // 2. Ищем первую субботу в прошлом, которая еще НЕ является черепом
      let found = false;
      for (let i = 0; i < 52; i++) {
        const dateKey = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        
        // Считаем субботу "чистой", если дата регистрации была позже неё 
        // ИЛИ если в этот день есть отметка об активности
        const isAlreadySkull = (currentCreatedAt <= d.getTime()) && !activity[dateKey];

        if (!isAlreadySkull) {
          const updates = {};
          
          // Удаляем отметку о присутствии
          updates[`activity/${dateKey}`] = null; 
          
          // Подвигаем дату регистрации, если нужно, чтобы суббота попала в отчетный период
          if (currentCreatedAt > d.getTime()) {
            updates[`createdAt`] = d.getTime() - (24 * 60 * 60 * 1000);
            currentCreatedAt = updates[`createdAt`]; // Обновляем для локального расчета ниже
          }
          
          // Применяем изменения в профиль пользователя
          await update(userRef, updates);
          console.log(`Добавлен череп пользователю ${targetId} за дату ${dateKey}`);
          
          // 3. ПРОВЕРКА НА КРИТИЧЕСКИЙ УРОВЕНЬ (БАН ПО IP)
          // Создаем временный объект, чтобы посчитать новый уровень черепов
          const updatedState = {
            ...data,
            createdAt: currentCreatedAt,
            activity: { ...activity, [dateKey]: null }
          };

          const newLevel = typeof getSkullLevel === 'function' ? getSkullLevel(updatedState) : 0;
          
          if (newLevel >= 4) {
            console.log("УРОВЕНЬ 4 ДОСТИГНУТ. Инициируем IP-бан...");
            
            // Если у нас есть IP этого пользователя (сохраненный при входе)
            if (data.lastIP && data.lastIP !== 'unknown') {
              const ipKey = data.lastIP.replaceAll('.', '_');
              await set(ref(db, `${basePath}/banned_ips/${ipKey}`), {
                uid: targetId,
                name: data.name || 'Чужой',
                bannedAt: serverTimestamp(),
                bannedUntil: Date.now() + (7 * 24 * 60 * 60 * 1000), // Бан на неделю
                reason: "Executed by admin"
              });
              console.log(`IP ${data.lastIP} успешно забанен в базе.`);
            } else {
              console.warn("IP пользователя неизвестен, бан применится только по ID.");
            }
          }

          found = true;
          break; 
        }
        d.setDate(d.getDate() - 7);
      }
      
      if (!found) console.warn("Не удалось добавить череп: достигнут лимит за год");
    }
      }
    return;
  }

  // 3. Команда помилования: /вернуть id
  if (txt.startsWith('/вернуть ')) {
    chatInputOverlay.value = '';
    const targetId = txt.replace('/вернуть ', '').trim();
    
    if (targetId) {
      const userRef = ref(db, `${basePath}/users/${targetId}`);
      await update(userRef, {
        isForgiven: true, // Наша функция getDisplayName это проверит и уберет черепа
        createdAt: Date.now() // Сбрасываем счетчик суббот на текущий момент
      });
      console.log(`Пользователь ${targetId} помилован`);
    }
    return;
  }

  // СООБЩЕНИЕ ТОЛЬКО НА СЕРВЕРНОМ ВРЕМЕНИ
  const msg = {
    uid: auth.currentUser?.uid || state.id,
    name: getDisplayName(state), // Вот здесь магия! || 'Чужой',
    color: state.color,
    emoji: (state.emoji || localStorage.getItem('cc_emoji') || ''),
    text: txt,
    t: serverTimestamp()        // <-- главное: серверный таймстемп
  };
  
  // Добавляем reply если выбрано
  if (replyToMessage) {
    msg.replyTo = replyToMessage.key;
    cancelReply();
  }

  chatInput.value = '';
  try{
    const key = push(chatRoot).key;
    await update(ref(db, `${basePath}/chat/${key}`), msg);
    
    // Проверяем RAT режим и планируем удаление через 5 минут
    const ratSnapshot = await get(ratModeRef);
    const ratActive = ratSnapshot.exists() && ratSnapshot.val().active;
    if (ratActive) {
      scheduleMessageDeletion(key, 5 * 60 * 1000); // 5 минут
    }
  }catch(e){
    console.error('❌ chat write failed', e);
    // можно вернуть текст в input, если хочешь
  }
}

// ===== Отправка в чат (оверлей) =====
async function sendChatOverlay(){
  if (!state.authed) return;
  const txt = chatInputOverlay.value.trim(); 
  if (!txt) return;

  // Если редактируем сообщение
  if (editingMessage) {
    await saveEditedMessage(txt);
    return;
  }

  // Проверяем команду /rat
  if (txt === '/rat') {
    chatInputOverlay.value = '';
    await toggleRatMode();
    return;
  }


// Команда /art — локальный арт-режим (только для этого юзера). Команда НЕ отправляется в чат.
if (txt === '/art') {
  if (typeof chatInput !== 'undefined') chatInput.value = '';
  if (typeof chatInputOverlay !== 'undefined') chatInputOverlay.value = '';
  toggleArtMode();
  return;
}

// Команда /random — выбираем победителя среди самых больших кластеров. Команда НЕ отправляется в чат.
if (txt === '/random') {
  if (typeof chatInput !== 'undefined') chatInput.value = '';
  if (typeof chatInputOverlay !== 'undefined') chatInputOverlay.value = '';
  startRandomPicker();
  return;
}


  const msg = {
    uid: auth.currentUser?.uid || state.id,
    name: getDisplayName(state) || 'Чужой',
    color: state.color,
    emoji: (state.emoji || localStorage.getItem('cc_emoji') || ''),
    text: txt,
    t: serverTimestamp()
  };
  
  // Добавляем reply если выбрано
  if (replyToMessage) {
    msg.replyTo = replyToMessage.key;
    cancelReply();
  }

  chatInputOverlay.value = '';
  try{
    const key = push(chatRoot).key;
    await update(ref(db, `${basePath}/chat/${key}`), msg);
    
    // Проверяем RAT режим и планируем удаление через 5 минут
    const ratSnapshot = await get(ratModeRef);
    const ratActive = ratSnapshot.exists() && ratSnapshot.val().active;
    if (ratActive) {
      scheduleMessageDeletion(key, 5 * 60 * 1000); // 5 минут
    }
  }catch(e){
    console.error('❌ chat write failed (overlay)', e);
  }
}



// === Overlay toast sound (simple beep) ===
let _toastAudioCtx = null;
function _ensureToastAudio(){
  if (_toastAudioCtx) return _toastAudioCtx;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    _toastAudioCtx = new AC();
    return _toastAudioCtx;
  } catch(e){ return null; }
}
function playOverlayToastBeep(){
  const ctxA = _ensureToastAudio();
  if (!ctxA) return;
  // audio может быть заблокирован до первого клика
  if (ctxA.state === 'suspended') {
    ctxA.resume().catch(()=>{});
  }
  try{
    const o = ctxA.createOscillator();
    const g = ctxA.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    g.gain.setValueAtTime(0.0001, ctxA.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, ctxA.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctxA.currentTime + 0.18);
    o.connect(g); g.connect(ctxA.destination);
    o.start();
    o.stop(ctxA.currentTime + 0.2);
  }catch(e){}
}
// инициализируем аудио по первому взаимодействию
window.addEventListener('pointerdown', ()=>{ _ensureToastAudio(); }, { once:true });

  // Overlay chat auto show/hide
  let overlayToastTimer=null;
  function showOverlayToast(m){
    if (!isOverlayMode()) return;
    const toast = document.getElementById('overlayToast');
    if (!toast) return;
    // Resolve uid even for Telegram-sourced messages
    const tgKey = (m && (m.tgUserId || m.telegramUserId || m.tg_user_id || m.telegram_id || m.tg_id || m.tgId || m.telegramId || m.telegramUserID || m.tguserid || m.tgUserID));
    const resolvedUid = (m && m.uid) ? m.uid : ((tgKey != null && state.tgIndex && state.tgIndex.get) ? state.tgIndex.get(String(tgKey)) : null);
    const resolvedColor = resolvedUid ? (state.presence?.get?.(resolvedUid)?.color || state.points?.get?.(resolvedUid)?.color) : null;
    const color = (m && m.color) ? m.color : (resolvedColor || (state.color || '#16c7b7'));
    const resolvedEmoji = resolvedUid ? (state.presence?.get?.(resolvedUid)?.emoji || state.points?.get?.(resolvedUid)?.emoji) : null;
    const emoji = (m && m.emoji) ? m.emoji : (resolvedEmoji || '💬');
    const text  = (m && m.text) ? m.text : '';
    toast.style.setProperty('--ot-color', color);
    toast.setAttribute('data-color','1');
    toast.innerHTML = `<div class="ot-emoji"><span class="ot-emoji-glyph">${escapeHtml(emoji || '⭕')}</span></div><div class="ot-text">${escapeHtml(text)}</div>`;
    toast.classList.add('show');
    playOverlayToastBeep();
    clearTimeout(overlayToastTimer);
    overlayToastTimer = setTimeout(()=> toast.classList.remove('show'), 3000);
  }
  // Чат управляется ТОЛЬКО через Python оверлей (Alt+F7)
  // Alt+~ убрали, чтобы не конфликтовать с другими приложениями

  // Persist overlay chat size (width/height)
  (function(){
    const keyW = 'overlay_chat_w', keyH = 'overlay_chat_h';
    function ensureDefaultChatHeight(){ if(!chatOverlay.style.height){ chatOverlay.style.height = '360px'; }}
    const savedW = localStorage.getItem(keyW), savedH = localStorage.getItem(keyH);
    if (savedW) chatOverlay.style.width = savedW;
    if (savedH) chatOverlay.style.height = savedH;
    ensureDefaultChatHeight();
    let saveTimer=null;
    const saveSize = ()=>{
      clearTimeout(saveTimer);
      saveTimer=setTimeout(()=>{
        localStorage.setItem(keyW, chatOverlay.style.width || chatOverlay.getBoundingClientRect().width+'px');
        localStorage.setItem(keyH, chatOverlay.style.height || chatOverlay.getBoundingClientRect().height+'px');
      }, 200);
    };
    // Save on mouseup (after resize) and on transition end
    chatOverlay.addEventListener('mouseup', saveSize);
    chatOverlay.addEventListener('mouseleave', saveSize);
    new MutationObserver(()=>saveSize()).observe(chatOverlay, { attributes:true, attributeFilter:['style']});
  })();


// ===== RAT РЕЖИМ =====
// Функция включения/выключения RAT режима
async function toggleRatMode() {
  try {
    const snapshot = await get(ratModeRef);
    const currentState = snapshot.exists() && snapshot.val().active;
    const newState = !currentState;
    
    await set(ratModeRef, {
      active: newState,
      changedAt: Date.now(),
      changedBy: auth.currentUser?.uid || state.id
    });
    
    // Показываем уведомление
    const statusMsg = newState ? '🐀 RAT режим ВКЛЮЧЕН' : '✅ RAT режим ВЫКЛЮЧЕН';
    showRatNotification(statusMsg);
    console.log(statusMsg);
  } catch(e) {
    console.error('❌ Ошибка переключения RAT режима:', e);
    showRatNotification('❌ Ошибка переключения RAT режима');
  }
}

// Планирование удаления сообщения через заданное время
function scheduleMessageDeletion(messageKey, delayMs) {
  setTimeout(async () => {
    try {
      const msgRef = ref(db, `${basePath}/chat/${messageKey}`);
      await remove(msgRef);
      console.log(`🗑️ Сообщение ${messageKey} удалено (RAT режим)`);
    } catch(e) {
      console.error(`❌ Ошибка удаления сообщения ${messageKey}:`, e);
    }
  }, delayMs);
}

// Показ уведомления о RAT режиме
function showRatNotification(message) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.95), rgba(185, 28, 28, 0.95));
    color: white;
    padding: 12px 24px;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(239, 68, 68, 0.4);
    z-index: 10001;
    font-weight: 700;
    font-size: 0.95em;
    animation: ratSlideIn 0.3s ease;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'ratSlideOut 0.3s ease';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Добавляем стили для анимации RAT уведомлений
const ratAnimStyle = document.createElement('style');
ratAnimStyle.textContent = `
  @keyframes ratSlideIn {
    from {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
    to {
      opacity: 1;
      transform: translate(-50%, 0);
    }
  }
  
  @keyframes ratSlideOut {
    from {
      opacity: 1;
      transform: translate(-50%, 0);
    }
    to {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
  }
`;
document.head.appendChild(ratAnimStyle);


  // Bridge for system hotkeys from overlay app
  window.overlayHotkey = (i)=>{
    try{
      const btns = reactionsBar?.querySelectorAll('button');
      const b = btns && btns[i];
      if (!b) return;
      b.classList.add('reaction-clicked');
      setTimeout(()=> b.classList.remove('reaction-clicked'), 300);
      sendReaction(b.dataset.emo||b.textContent);
    }catch(e){ console.warn('overlayHotkey error', e); }
  };
  
  

  // ===== RANDOM sync (broadcast to all clients via Firebase) =====
  // Идея: команда /random и Alt+Shift+R должны запускать рандом ОДНОВРЕМЕННО у всех.
  // Поэтому мы не запускаем startRandomPicker() локально "втихаря", а пишем событие в базу.
  // Все клиенты подписаны на /commands/random и проигрывают анимацию при новом событии.
  const randomCmdRoot = ref(db, `${basePath}/commands/random`);
  let __randomBindAt = Date.now();
  let __randomLastKey = null;
  let __randomLocalTs = 0;

  function triggerRandomBroadcast(){
    const t = Date.now();
    __randomLocalTs = t;
    // Локально стартуем сразу, чтобы не ждать round-trip
    try { startRandomPicker(); } catch {}
    // Пишем событие в базу — остальные (и хост) подхватят
    try { push(randomCmdRoot, { t, by: (typeof siteUserId !== 'undefined' ? siteUserId : null) }); } catch(e){}
  }

  function bindRandomBroadcast(){
    if (window.__randomBroadcastBound) return;
    window.__randomBroadcastBound = true;

    __randomBindAt = Date.now();
    // Берём только "хвост", но onChildAdded всё равно выдаст 1 старый элемент — отсекаем по времени.
    const q = query(randomCmdRoot, orderByChild('t'), limitToLast(1));

    onChildAdded(q, (snap)=>{
      try{
        if (!snap.exists()) return;
        if (snap.key && snap.key === __randomLastKey) return;
        __randomLastKey = snap.key || __randomLastKey;

        const v = snap.val() || {};
        const t = Number(v.t || 0);
        const by = v.by;

        // Не проигрываем "исторический" последний элемент при первом подключении
        if (t && t < (__randomBindAt - 500)) return;

        // Не дублируем собственный запуск (мы уже стартанули локально)
        if (by && typeof siteUserId !== 'undefined' && by === siteUserId){
          if (__randomLocalTs && Math.abs(t - __randomLocalTs) < 2000) return;
        }

        triggerRandomBroadcast();
      }catch(e){
        console.warn('[random] broadcast handler error', e);
      }
    });
  }

  // Стартуем подписку сразу
  try { bindRandomBroadcast(); } catch(e) { console.warn('[random] bind failed', e); }


  // ===== RANDOM hotkey (Alt+Shift+R) =====
  // Работает и в overlay и в обычном режиме, но не срабатывает, если фокус в инпуте.
  window.addEventListener('keydown', (e)=>{
    const tag = (document.activeElement||{}).tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return;
    if (e.repeat) return;
    if (e.code === 'KeyR' && e.altKey && e.shiftKey && !e.ctrlKey && !e.metaKey){
      triggerRandomBroadcast();
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);

// ЗАКРЫТИЕ ОВЕРЛЕЯ: Escape в overlay режиме
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Escape' && isOverlayMode()){
      // Информируем Python оверлей о закрытии
      if (confirm('Закрыть оверлей?')) {
        window.close(); // Попытка закрыть окно
      }
      e.preventDefault();
    }
  });

  function renderChat(msgs){
    chatListSite.innerHTML=''; chatListOverlay.innerHTML='';
    for (const m of msgs){
      const currentUserId = auth.currentUser?.uid || state.id;
      const isOwnMessage = m.uid === currentUserId;
      
      // Создаём элемент для сайта
      const elSite = document.createElement('div'); 
      elSite.className='chat-msg' + (isOwnMessage ? ' own-message' : '');
      elSite.dataset.msgKey = m.key;
      elSite.dataset.msgUid = m.uid;
      elSite.dataset.msgTimestamp = m.t || m.ts || 0;
      
      // Создаём элемент для оверлея
      const elOverlay = document.createElement('div'); 
      elOverlay.className='chat-msg' + (isOwnMessage ? ' own-message' : '');
      elOverlay.dataset.msgKey = m.key;
      elOverlay.dataset.msgUid = m.uid;
      elOverlay.dataset.msgTimestamp = m.t || m.ts || 0;
      
      let html = '';
      
      // Если есть reply - показываем превью
      if (m.replyTo) {
        const replyMsg = msgs.find(msg => msg.key === m.replyTo);
        if (replyMsg) {
          const replyName = escapeHtml(replyMsg.name || 'Чужой');
          const replyText = escapeHtml((replyMsg.text || '').substring(0, 50));
          html += `<div class="chat-msg-reply-preview" data-reply-to="${m.replyTo}">
            <b style="color:${replyMsg.color||'#ccc'}">${replyName}</b>: ${replyText}${(replyMsg.text||'').length > 50 ? '...' : ''}
          </div>`;
        }
      }
      
      // Заголовок сообщения с именем
      const name = escapeHtml(m.name||'Чужой');
      const text = escapeHtml(m.text||'');
      const edited = m.edited ? '<span style="color:var(--muted);font-size:0.8em;margin-left:4px">(изменено)</span>' : '';
      
      html += `<div class="chat-msg-header">
        <b style="color:${m.color||'#ccc'}">${name}</b>
      </div>
      <div class="chat-msg-text">${text}${edited}</div>`;
      
      elSite.innerHTML = html;
      elOverlay.innerHTML = html;
      
      // Назначаем обработчики
      setupMessageHandlers(elSite, m);
      setupMessageHandlers(elOverlay, m);
      
      chatListSite.appendChild(elSite);
      chatListOverlay.appendChild(elOverlay);
    }
    chatListSite.scrollTop = chatListSite.scrollHeight;
    chatListOverlay.scrollTop = chatListOverlay.scrollHeight;
  }
  
  function setupMessageHandlers(el, m) {
    let touchTimer = null;
    let touchStartTime = 0;
    
    // Двойной клик (ПК) - сразу фокус на поле ввода
    el.addEventListener('dblclick', (e) => {
      e.preventDefault();
      setReplyTo(m);
      // Сразу фокусируем поле ввода
      if (el.closest('#chatPanel')) {
        chatInput.focus();
      } else {
        chatInputOverlay.focus();
      }
    });
    
    // Правая кнопка мыши (ПК)
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showContextMenu(e, m);
    });
    
    // Touch events (мобильный)
    el.addEventListener('touchstart', (e) => {
      touchStartTime = Date.now();
      touchTimer = setTimeout(() => {
        // Удержание - показываем меню
        showContextMenu(e.touches[0], m);
        navigator.vibrate && navigator.vibrate(50);
      }, 500);
    });
    
    el.addEventListener('touchend', (e) => {
      clearTimeout(touchTimer);
      const touchDuration = Date.now() - touchStartTime;
      
      // Двойной тап за быстрое время - автоответ и фокус
      if (touchDuration < 300 && el._lastTouchEnd && (Date.now() - el._lastTouchEnd) < 300) {
        e.preventDefault();
        setReplyTo(m);
        // Сразу фокусируем поле ввода
        if (el.closest('#chatPanel')) {
          chatInput.focus();
        } else {
          chatInputOverlay.focus();
        }
        el._lastTouchEnd = 0;
      } else {
        el._lastTouchEnd = Date.now();
      }
    });
    
    el.addEventListener('touchmove', () => {
      clearTimeout(touchTimer);
    });
    
    // Клик по превью реплая - прокрутка к сообщению
    const replyPreview = el.querySelector('.chat-msg-reply-preview');
    if (replyPreview) {
      replyPreview.addEventListener('click', (e) => {
        e.stopPropagation();
        const targetKey = replyPreview.dataset.replyTo;
        const targetEl = document.querySelector(`[data-msg-key="${targetKey}"]`);
        if (targetEl) {
          targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          targetEl.style.background = 'rgba(22,199,183,0.3)';
          setTimeout(() => {
            targetEl.style.background = '';
          }, 1000);
        }
      });
    }
  }
  
  function setReplyTo(msg) {
    // Отменяем редактирование если оно было
    cancelEdit();
    
    replyToMessage = msg;
    
    // Убираем старый индикатор
    document.querySelectorAll('.chat-msg.replying').forEach(el => {
      el.classList.remove('replying');
      const cancel = el.querySelector('.chat-msg-reply-cancel');
      if (cancel) cancel.remove();
    });
    
    // Добавляем новый индикатор
    const targetEls = document.querySelectorAll(`[data-msg-key="${msg.key}"]`);
    targetEls.forEach(el => {
      el.classList.add('replying');
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'chat-msg-reply-cancel';
      cancelBtn.textContent = '✕';
      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        cancelReply();
      };
      el.appendChild(cancelBtn);
    });
    
    hideContextMenu();
  }
  
  function cancelReply() {
    replyToMessage = null;
    document.querySelectorAll('.chat-msg.replying').forEach(el => {
      el.classList.remove('replying');
      const cancel = el.querySelector('.chat-msg-reply-cancel');
      if (cancel) cancel.remove();
    });
  }
  
  function showContextMenu(e, msg) {
    const menu = chatContextMenu;
    menu.classList.add('show');
    
    const x = e.clientX || e.pageX;
    const y = e.clientY || e.pageY;
    
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    
    // Проверяем, является ли сообщение нашим
    const currentUserId = auth.currentUser?.uid || state.id;
    const isOwnMessage = msg.uid === currentUserId;
    const messageTime = msg.t || msg.ts || 0;
    const timeSinceMessage = Date.now() - messageTime;
    
    // Показываем/скрываем кнопки в зависимости от времени
    const canEdit = isOwnMessage && timeSinceMessage <= 60 * 60 * 1000; // 1 час
    const canDelete = isOwnMessage && timeSinceMessage <= 30 * 60 * 1000; // 30 минут
    
    contextEdit.style.display = canEdit ? 'block' : 'none';
    contextDelete.style.display = canDelete ? 'block' : 'none';
    
    // Обновляем обработчики
    contextReply.onclick = () => {
      setReplyTo(msg);
    };
    
    contextEdit.onclick = () => {
      if (canEdit) startEditMessage(msg);
    };
    
    contextDelete.onclick = () => {
      if (canDelete) deleteMessage(msg);
    };
  }
  
  function hideContextMenu() {
    chatContextMenu.classList.remove('show');
  }
  
  // Закрытие контекстного меню при клике вне его
  document.addEventListener('click', (e) => {
    if (!chatContextMenu.contains(e.target)) {
      hideContextMenu();
    }
  });
  
  // === РЕДАКТИРОВАНИЕ СООБЩЕНИЙ ===
  function startEditMessage(msg) {
    // Отменяем reply если был
    cancelReply();
    
    editingMessage = msg;
    
    // Убираем старые индикаторы редактирования
    document.querySelectorAll('.chat-msg-editing').forEach(el => {
      el.classList.remove('chat-msg-editing');
    });
    
    // Добавляем индикатор к редактируемому сообщению
    const targetEls = document.querySelectorAll(`[data-msg-key="${msg.key}"]`);
    targetEls.forEach(el => {
      el.classList.add('chat-msg-editing');
    });
    
    // Заполняем поле ввода текстом сообщения
    chatInput.value = msg.text || '';
    chatInputOverlay.value = msg.text || '';
    
    // Фокусируем поле
    chatInput.focus();
    chatInputOverlay.focus();
    
    hideContextMenu();
  }
  
  function cancelEdit() {
    if (!editingMessage) return;
    
    editingMessage = null;
    
    // Убираем индикаторы редактирования
    document.querySelectorAll('.chat-msg-editing').forEach(el => {
      el.classList.remove('chat-msg-editing');
    });
    
    // Очищаем поля ввода
    chatInput.value = '';
    chatInputOverlay.value = '';
  }
  
  async function saveEditedMessage(text) {
    if (!editingMessage || !auth.currentUser) return false;
    
    const currentUserId = auth.currentUser.uid || state.id;
    if (editingMessage.uid !== currentUserId) {
      alert('Вы можете редактировать только свои сообщения');
      cancelEdit();
      return false;
    }
    
    const messageTime = editingMessage.t || editingMessage.ts || 0;
    const timeSinceMessage = Date.now() - messageTime;
    
    if (timeSinceMessage > 60 * 60 * 1000) {
      alert('Можно редактировать только сообщения младше 1 часа');
      cancelEdit();
      return false;
    }
    
    try {
      const msgRef = ref(db, `${basePath}/chat/${editingMessage.key}`);
      await update(msgRef, {
        text: text,
        edited: true,
        editedAt: serverTimestamp()
      });
      
      // Обновляем локальное сообщение
      const index = msgs.findIndex(m => m.key === editingMessage.key);
      if (index >= 0) {
        msgs[index].text = text;
        msgs[index].edited = true;
        msgs[index].editedAt = Date.now();
        renderChat(msgs);
      }
      
      cancelEdit();
      return true;
    } catch (e) {
      console.error('Failed to edit message:', e);
      alert('Ошибка при редактировании сообщения');
      return false;
    }
  }
  
  // === УДАЛЕНИЕ СООБЩЕНИЙ ===
  async function deleteMessage(msg) {
    if (!confirm('Удалить это сообщение?')) return;
    
    if (!auth.currentUser) return;
    
    const currentUserId = auth.currentUser.uid || state.id;
    if (msg.uid !== currentUserId) {
      alert('Вы можете удалять только свои сообщения');
      return;
    }
    
    const messageTime = msg.t || msg.ts || 0;
    const timeSinceMessage = Date.now() - messageTime;
    
    if (timeSinceMessage > 30 * 60 * 1000) {
      alert('Можно удалять только сообщения младше 30 минут');
      return;
    }
    
    try {
      // Удаляем из Firebase
      await remove(ref(db, `${basePath}/chat/${msg.key}`));
      
      // Удаляем из локального массива (для мгновенного обновления UI)
      const index = msgs.findIndex(m => m.key === msg.key);
      if (index >= 0) {
        msgs.splice(index, 1);
        renderChat(msgs);
        state.localChat = msgs.slice(-100);
        localStorage.setItem('cc_chat_cache', JSON.stringify(state.localChat));
      }
      
      hideContextMenu();
    } catch (e) {
      console.error('Failed to delete message:', e);
      alert('Ошибка при удалении сообщения');
    }
  }
  
  // Отмена reply и edit при Escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (replyToMessage) {
        cancelReply();
        e.preventDefault();
      }
      if (editingMessage) {
        cancelEdit();
        e.preventDefault();
      }
    }
    
    // Клавиша Вверх для редактирования последнего сообщения (только на ПК)
    if (e.key === 'ArrowUp' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
      const activeEl = document.activeElement;
      // Только если фокус в поле ввода чата и оно пустое
      if ((activeEl === chatInput || activeEl === chatInputOverlay) && activeEl.value.trim() === '') {
        // Находим последнее своё сообщение
        const currentUserId = auth.currentUser?.uid || state.id;
        const myMessages = msgs.filter(m => m.uid === currentUserId);
        if (myMessages.length > 0) {
          const lastMsg = myMessages[myMessages.length - 1];
          const messageTime = lastMsg.t || lastMsg.ts || 0;
          const timeSinceMessage = Date.now() - messageTime;
          
          // Проверяем, что сообщение младше 1 часа
          if (timeSinceMessage <= 60 * 60 * 1000) {
            startEditMessage(lastMsg);
            e.preventDefault();
          }
        }
      }
    }
  });
  
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

  
  function renderReactions(items){
    // Реакции ТОЛЬКО в оверлее!
    if (!isOverlayMode()) return;
    const now = Date.now();
    // Это будет делаться через onValue с последней реакцией
  }
  
  // УЛУЧШЕННАЯ функция spawnEmoji: ОДНО эмодзи, случайный размер и позиция
function spawnEmoji(it){
  const layer = fxLayer || document.getElementById('fx-layer');
  if (!layer) { console.warn('spawnEmoji: fx-layer not found'); return; }

  const isPng = (it.type === 'png' && it.src);
  const el = document.createElement('div');

  const stroke = it.color || state.color || '#16c7b7';

  if (isPng) {
    el.className = 'emoji stroke';
    el.style.setProperty('--emoji-stroke', stroke);

    const img = document.createElement('img');
    img.src = it.src;
    img.alt = 'Reaction';
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'contain';
    el.appendChild(img);
    el.style.width = '256px'; // Или 512px, если новые файлы
    el.style.height = '256px';
  } else {
    // Обычная (Unicode) реакция — НЕ красим оверлеем, только нормальное свечение как раньше
    el.className = 'emoji stroke';
    el.style.setProperty('--emoji-stroke', stroke);

    const emo = (it.emoji ?? it.emo) || '❤️';
    el.textContent = emo;
}

  const w = layer.clientWidth || window.innerWidth;
  const h = layer.clientHeight || window.innerHeight;

  // СЛУЧАЙНЫЙ РАЗМЕР (от 30px до 60px)
  const randomSize = 30 + Math.random() * 30;
  if (!isPng) {
    el.style.fontSize = randomSize + 'px';
  } else {
    el.style.width = randomSize + 'px';
    el.style.height = randomSize + 'px';
  }

  // СЛУЧАЙНАЯ СТАРТОВАЯ ПОЗИЦИЯ ПО ШИРИНЕ (20% - 80% экрана)
  const startX = Math.random() * w * 0.6 + w * 0.2;
  const startY = h + 50;
  const endX = startX + (Math.random() * 80 - 40);
  const endY = h * 0.15 + Math.random() * 120;

  el.style.left = startX + 'px';
  el.style.top  = startY + 'px';
  el.style.opacity = '0';

  layer.appendChild(el);

  const t0 = performance.now();
  const dur = 2500 + Math.random() * 1000;
  const rotationSpeed = (Math.random() - 0.5) * 120;

  (function step(t){
    const k = Math.min(1, (t - t0)/dur);
    const ease = 1 - Math.pow(1-k, 3);

    const x = startX + (endX-startX)*ease;
    const y = startY - (startY-endY)*ease;

    const scale = 0.8 + 0.5*Math.sin(k*Math.PI);

    let opacity;
    if (k < 0.1) opacity = k * 10;
    else if (k > 0.8) opacity = (1-k) * 5;
    else opacity = 1;

    el.style.transform = `translate(${x-startX}px, ${-(startY-y)}px) scale(${scale}) rotate(${rotationSpeed*k}deg)`;
    el.style.opacity = opacity.toFixed(3);

    if (k < 1) requestAnimationFrame(step);
    else el.remove();
  })(performance.now());
}

window.spawnEmoji = spawnEmoji;

  /* ======= CLUSTERING & RENDER ======= */

  // Функция для определения уровня "проклятия" (черепов)
  function getSkullLevel(userData) {
    if (!userData || !userData.createdAt) return 0;
    if (userData.isForgiven) return 0; // Если админ простил

    const start = new Date(userData.createdAt);
    const end = new Date();
    let missedSaturdays = 0;

    // Считаем все субботы с момента регистрации до сегодня
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      if (d.getDay() === 6) { // 6 = Суббота
        const dateKey = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        // Если в эту субботу не заходил (нет записи в activity)
        if (!userData.activity || !userData.activity[dateKey]) {
          missedSaturdays++;
        }
      }
    }
    // Уровни: 0 (ок), 1-3 (черепа), 4 (смерть/бан)
    return Math.min(missedSaturdays, 4);
  }

  // Массив эмодзи для уровней
  const SKULL_EMOJIS = ["", "💀", "💀💀", "💀💀💀", "⚰️"];

  function getDisplayName(it) {
    if (!it) return 'Чужой';
    
    // Берем имя, если его нет — ищем в глобальном state
    let rawName = it.name || (it === state ? state.name : 'Чужой');
    
    // Если даты нет или она еще не число (serverTimestamp), просто отдаем имя
    if (!it.createdAt || typeof it.createdAt !== 'number') {
      return rawName;
    }

    try {
      const start = new Date(it.createdAt);
      const end = new Date();
      if (isNaN(start.getTime())) return rawName; // Защита от кривых дат

      let missedSaturdays = 0;
      // Клонируем дату, чтобы не испортить оригинал
      let d = new Date(start.getTime());
      while (d <= end) {
        if (d.getDay() === 6) { // Суббота
          const dateKey = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          if (!it.activity || !it.activity[dateKey]) {
            missedSaturdays++;
          }
        }
        d.setDate(d.getDate() + 1);
      }

      const level = Math.min(missedSaturdays, 4);
      const skulls = ["", "💀", "💀💀", "💀💀💀", "⚰️"];
      return rawName + (skulls[level] ? " " + skulls[level] : "");
    } catch (e) {
      return rawName;
    }
  }


  const CLUSTER_DIST_FACTOR = 5.0; // увеличил с 3.3 для лучшего слипания
  const clusterAnim = new Map();

  function hexToRgb(hex){
    try{ const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return {r:22,g:199,b:183};
      return { r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16) };
    }catch{ return {r:22,g:199,b:183}; }
  }

  function lightenHex(hex, amount){
    // amount: 0..1 (towards white)
    const {r,g,b} = hexToRgb(hex);
    const rr = Math.round(r + (255 - r) * amount);
    const gg = Math.round(g + (255 - g) * amount);
    const bb = Math.round(b + (255 - b) * amount);
    return '#' + [rr,gg,bb].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  function rgba(o,a=1){ return `rgba(${o.r},${o.g},${o.b},${a})`; }
  function darken({r,g,b}, f=0.28){ return { r:Math.round(r*(1-f)), g:Math.round(g*(1-f)), b:Math.round(b*(1-f)) }; }
  function baseRadiusPx(){
    const r=videoRect();
    const d = Math.min(r.w, r.h);
    // Адаптивный размер: УМЕНЬШЕН В 2.5 РАЗА (было 2.5%, стало 1%)
    return Math.max(6, d*0.01);
  }
  function computeClusters(){
    const all = [...state.points.values()];
    if (!(state.mode === 'overlay' || state.showClustersOnSite)) return [];
    
    // Показываем всех (убрали фильтр оффлайн)
    const currentUid = (auth.currentUser&&auth.currentUser.uid)||state.id;
    const filtered = all;
    
    const br = baseRadiusPx();
    const CLUSTER_DIST = br * CLUSTER_DIST_FACTOR;

    const items = filtered.map(p=>{
      const P = pxFromNorm(p.x,p.y);
      return { id:p.id||p.uid, name:p.name||'', emoji:p.emoji||'', nx:p.x, ny:p.y, x:P.x, y:P.y, color:p.color||DEFAULT_COLOR };
    });


  // Улучшенная кластеризация: если A близко к B, а B близко к C, то все трое в одном кластере
    const used = new Set();
    const clusters = [];
    
    for (let i=0; i<items.length; i++){
      if (used.has(items[i].id)) continue;
      
      const group = [items[i]];
      used.add(items[i].id);
      
      // Продолжаем добавлять в группу, пока находим новые близкие точки
      let changed = true;
      while (changed) {
        changed = false;
        for (let j=0; j<items.length; j++){
          if (used.has(items[j].id)) continue;
          
          // Проверяем, есть ли хотя бы одна точка в группе, близкая к items[j]
          let isNear = false;
          for (const g of group){
            const dx = items[j].x - g.x;
            const dy = items[j].y - g.y;
            if (Math.hypot(dx, dy) <= CLUSTER_DIST){
              isNear = true;
              break;
            }
          }
          
          if (isNear){
            group.push(items[j]);
            used.add(items[j].id);
            changed = true; // продолжаем поиск
          }
        }
      }
      
      clusters.push(group);
    }

    return clusters.map(group=>{
      let sx=0, sy=0, snx=0, sny=0;
      const colors = group.map(g=>g.color);
      for (const g of group){ sx+=g.x; sy+=g.y; snx+=g.nx; sny+=g.ny; }
      const cx = sx/group.length, cy=sy/group.length;
      const cnx = snx/group.length, cny=sny/group.length;
      const n = group.length;
      const r2 = baseRadiusPx() * (1.2 + 1.2*Math.pow(2, 0.65));
      let scale = 1;
      if (n === 1) scale = 0.5;
      else if (n > 2) scale = 1 + (n - 2) * 0.25;
      const r = r2 * scale; // 1x=0.5, 2x=как было, 3x=+25%, 4x=+50%, ...
      const key = group.map(g=>g.id||g.name).sort().join('|') || (cnx.toFixed(4)+','+cny.toFixed(4));
      return { key, size:group.length, cx, cy, cnx, cny, r, colors, members:group };
    });

  }



  
  // ======= RANDOM MAX-CLUSTER PICKER (/random, Alt+Shift+R) =======
  // Логика выбора:
  // - берём максимальный размер кластера (size max).
  // - выбираем ВСЕ кластеры этого размера.
  // - анимация: 3с "мигание" (по очереди раздуваем/сжимаем), сначала быстро, потом медленнее.
  // - затем 1 победитель раздувается на 2с.
  let randomPickState = null;

  function _buildRandomSteps(keys, totalMs=3000){
    // интервалы растут от fast->slow
    const steps = [];
    let t = 0;
    let k = 0;
    if (!keys || !keys.length) return steps;

    // Чтобы не было тупого циклического "1-2-3-1-2-3" — слегка мешаем порядок каждый круг
    let bag = keys.slice();
    const reshuffle = ()=>{
      // Fisher–Yates
      for (let i = bag.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
    };
    reshuffle();

    while (t < totalMs){
      const p = t / totalMs;            // 0..1
      const ease = p*p;                 // медленнее к концу
      const interval = Math.max(70, Math.min(420, lerp(90, 340, ease))); // ms
      const key = bag[k % bag.length];
      steps.push({ key, t0: t, t1: Math.min(totalMs, t + interval) });
      t += interval;

      k++;
      // каждый полный проход — мешаем ещё раз
      if (k % bag.length === 0) reshuffle();
    }
    return steps;
  }

  function startRandomPicker(){
    // вычисляем кластеры "как они есть сейчас"
    const clusters = computeClusters();
    if (!clusters || clusters.length === 0){
      try { showToast('RANDOM: кластеров нет'); } catch {}
      return;
    }

    let maxSize = 1;
    for (const c of clusters) maxSize = Math.max(maxSize, c.size || 1);

    const selected = clusters.filter(c => (c.size || 1) === maxSize);
    const keys = selected.map(c=>c.key).filter(Boolean);

    if (!keys.length){
      try { showToast('RANDOM: нечего выбирать'); } catch {}
      return;
    }

    const winnerKey = keys[Math.floor(Math.random() * keys.length)];
    const steps = _buildRandomSteps(keys, 3000);

    randomPickState = {
      startedAt: performance.now(),
      blinkMs: 3000,
      winnerMs: 2000,
      steps,
      keysSet: new Set(keys),
      winnerKey
    };

    try { showToast(`RANDOM: выбрано кластеров ${keys.length} (size=${maxSize})`); } catch {}
  }

  function getRandomClusterScale(key, nowPerf){
    if (!randomPickState) return 1;

    const t = nowPerf - randomPickState.startedAt;
    const blinkEnd = randomPickState.blinkMs;
    const winnerEnd = randomPickState.blinkMs + randomPickState.winnerMs;

    // 1) мигание 0..3s
    if (t >= 0 && t < blinkEnd){
      // находим текущий шаг
      let step = null;
      const tt = t;
      for (let i = 0; i < randomPickState.steps.length; i++){
        const s = randomPickState.steps[i];
        if (tt >= s.t0 && tt < s.t1){ step = s; break; }
      }
      if (!step) return 1;

      if (key !== step.key) return 1;

      const phase = (tt - step.t0) / Math.max(1, (step.t1 - step.t0)); // 0..1
      const pulse = Math.sin(Math.PI * phase); // 0..1..0
      return 1 + 0.28 * pulse; // "вырастать и уменьшаться"
    }

    // 2) победитель 3..5s
    if (t >= blinkEnd && t < winnerEnd){
      if (key === randomPickState.winnerKey) return 1.35;
      return 1;
    }

    // 3) конец
    randomPickState = null;
    return 1;
  }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function jelly(st){
    if (st.pulse<=0) return 1;
    const t = 1 - st.pulse;
    const c1 = 1.70158, c3 = c1 + 1;
    const overshoot = (1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2));
    return 1 + 0.14*overshoot;
  }
  function animStateFor(key, target){
    const prev = clusterAnim.get(key);
    if (!prev){
      const seed = target.members[0];
      const st = { x: seed?.x ?? target.cx, y: seed?.y ?? target.cy, r: target.r*0.8, size: target.size, pulse: 1 };
      clusterAnim.set(key, st); return st;
    }
    if (prev.size < target.size){ prev.pulse = 1; prev.size = target.size; }
    return prev;
  }
  function stepTowards(st, target, dt){
    const speed = 0.35; // увеличил с 0.18 для более быстрой анимации
    st.x = lerp(st.x, target.cx, speed);
    st.y = lerp(st.y, target.cy, speed);
    st.r = lerp(st.r, target.r * jelly(st), speed);
    st.pulse = Math.max(0, st.pulse - dt*5.5); // увеличил с 3.2 для более быстрого затухания пульса
  }

  
  // ===== TINTED EMOJI RENDER (no squares) =====
  // We render emoji to an offscreen canvas in grayscale, then recolor only non-transparent pixels.
  const _emojiOff = document.createElement('canvas');
  const _emojiCtx = _emojiOff.getContext('2d', { willReadFrequently: true });

  function _drawTintedEmoji(targetCtx, glyph, x, y, fontPx, colorHex, opts){
    if (!glyph) return;

    const rgb = hexToRgb(colorHex || DEFAULT_COLOR);
    opts = opts || {};

    // opts.brightness used to be additive (-0.3..+0.3). Here we map it to a multiplier for CSS brightness().
    const brightness = (typeof opts.brightness === 'number') ? opts.brightness : 0.0;
    const contrast   = (typeof opts.contrast === 'number')   ? opts.contrast   : 1.0;

    const outline    = !!opts.outline;
    const outlineWidth = (typeof opts.outlineWidth === 'number') ? opts.outlineWidth : 2; // px in offscreen space
    const outlineMixSeeThrough = (typeof opts.outlineAlpha === 'number') ? opts.outlineAlpha : 0.75;

    // Outline color = чуть светлее выбранного, чтобы сочеталось с шаром
    const o = {
      r: Math.min(255, Math.round(rgb.r + (255 - rgb.r) * 0.35)),
      g: Math.min(255, Math.round(rgb.g + (255 - rgb.g) * 0.35)),
      b: Math.min(255, Math.round(rgb.b + (255 - rgb.b) * 0.35)),
    };

    // Convert selected color to hue, then compensate filter's hue shift.
    function _rgbToHue(_r,_g,_b){
      const r=_r/255, g=_g/255, b=_b/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      if (d===0) return 0;
      let h;
      if (max===r) h=((g-b)/d)%6;
      else if (max===g) h=(b-r)/d + 2;
      else h=(r-g)/d + 4;
      h*=60;
      if (h<0) h+=360;
      return h;
    }

    const targetHue = _rgbToHue(rgb.r, rgb.g, rgb.b);

    // Compute base hue of sepia-toned mid-gray (after grayscale+sepia):
    const _mid = 128;
    const _sepR = Math.min(255, Math.round(_mid * (0.393+0.769+0.189)));
    const _sepG = Math.min(255, Math.round(_mid * (0.349+0.686+0.168)));
    const _sepB = Math.min(255, Math.round(_mid * (0.272+0.534+0.131)));
    const BASE_HUE = _rgbToHue(_sepR,_sepG,_sepB);
    const rotate = ( (targetHue - BASE_HUE) % 360 + 360 ) % 360;

    // Filter chain (your "sepia base" method), plus per-call contrast/brightness tweaks.
    const baseBright = 0.97;
    const brightMul = Math.max(0.1, Math.min(2.5, baseBright * (1 + brightness)));
    const contrastMul = Math.max(0.2, Math.min(1.6, contrast));

    const box = Math.max(48, Math.ceil(fontPx * 2.1));
    _emojiOff.width = box;
    _emojiOff.height = box;

    _emojiCtx.clearRect(0,0,box,box);
    _emojiCtx.save();
    _emojiCtx.textAlign = 'center';
    _emojiCtx.textBaseline = 'middle';
    _emojiCtx.font = `900 ${Math.round(fontPx)}px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji','Twemoji Mozilla','Segoe UI Symbol',sans-serif`;

    // If chosen color is grayscale (r=g=b), disable sepia/hue-rotate so black/white/gray stay true.
    const isGray = (rgb.r === rgb.g && rgb.g === rgb.b);

    // mono mode (offline): чистый ч/б без сепии/окраски
    if (opts.mono){
      _emojiCtx.filter = `grayscale(1) sepia(0) saturate(1) brightness(1) contrast(1.15)`;
    } else if (isGray){
      const targetGray = rgb.r; // 0..255
      const grayMul = Math.max(0.05, Math.min(2.5, (targetGray / 128) * brightMul));
      _emojiCtx.filter = `grayscale(1) sepia(0) saturate(1) brightness(${grayMul}) contrast(${contrastMul})`;
    } else {
      _emojiCtx.filter = `grayscale(1) sepia(1) saturate(1.35) hue-rotate(${rotate}deg) brightness(${brightMul}) contrast(${contrastMul})`;
    }
    _emojiCtx.fillText(glyph, box/2, box/2);
    _emojiCtx.filter = 'none';

    // Outline without squares: dilate alpha mask, paint only outside original shape.
    if (outline){
      const img = _emojiCtx.getImageData(0,0,box,box);
      const d = img.data;

      const w = box, h = box;
      const alphaMask = new Uint8ClampedArray((d.length/4)|0);
      for (let i=0, j=0; i<d.length; i+=4, j++) alphaMask[j] = d[i+3];

      const out = new Uint8ClampedArray(alphaMask.length);
      const r = Math.max(1, Math.round(outlineWidth));

      // dilation: for each pixel, take max alpha in radius r neighborhood
      for (let y0=0; y0<h; y0++){
        const yMin = Math.max(0, y0 - r);
        const yMax = Math.min(h-1, y0 + r);
        for (let x0=0; x0<w; x0++){
          const xMin = Math.max(0, x0 - r);
          const xMax = Math.min(w-1, x0 + r);
          let maxA = 0;
          for (let yy=yMin; yy<=yMax; yy++){
            const row = yy*w;
            for (let xx=xMin; xx<=xMax; xx++){
              const a = alphaMask[row + xx];
              if (a > maxA) maxA = a;
              if (maxA === 255) break;
            }
            if (maxA === 255) break;
          }
          out[y0*w + x0] = maxA;
        }
      }

      // paint outline where out>0 but original alpha==0
      for (let i=0, j=0; i<d.length; i+=4, j++){
        if (alphaMask[j] !== 0) continue;
        const a = out[j];
        if (a === 0) continue;

        const oa = Math.round(a * outlineMixSeeThrough);
        d[i]   = o.r;
        d[i+1] = o.g;
        d[i+2] = o.b;
        d[i+3] = oa;
      }

      _emojiCtx.putImageData(img,0,0);
    }

    _emojiCtx.restore();
    targetCtx.drawImage(_emojiOff, x - box/2, y - box/2);
  }
function drawSingleDot(px, py, radius, p){
  // v38 guard: avoid NaN/Infinity crashing Canvas gradients
  if (!Number.isFinite(px) || !Number.isFinite(py)) return;
  if (!Number.isFinite(radius) || radius <= 0) radius = 18;

    const base = hexToRgb((p && p.color) ? p.color : DEFAULT_COLOR);
    const dark = darken(base, 0.4);
    const dpr = (window.devicePixelRatio || 1);
    const rr = Math.max(1, radius * dpr);

    ctx.save();
    
    // Внешнее сияние
    const outerGlow = ctx.createRadialGradient(px, py, rr * 0.3, px, py, rr * 1.6);
    outerGlow.addColorStop(0, `rgba(${base.r},${base.g},${base.b},0.3)`);
    outerGlow.addColorStop(0.5, `rgba(${base.r},${base.g},${base.b},0.15)`);
    outerGlow.addColorStop(1, `rgba(${base.r},${base.g},${base.b},0)`);
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(px, py, rr * 1.6, 0, Math.PI * 2);
    ctx.fill();

    // Основной градиент (объемный)
    ctx.globalCompositeOperation = 'source-over';
    const grad = ctx.createRadialGradient(px - rr*0.35, py - rr*0.35, rr*0.1, px, py, rr);
    grad.addColorStop(0.00, 'rgba(255,255,255,0.95)');
    grad.addColorStop(0.15, `rgba(${Math.min(255,base.r+60)},${Math.min(255,base.g+60)},${Math.min(255,base.b+60)},0.9)`);
    grad.addColorStop(0.50, rgba(base, .85));
    grad.addColorStop(0.85, rgba(dark, .75));
    grad.addColorStop(1.00, rgba(darken(base, 0.55), .6));

    ctx.shadowColor = rgba(base, .4);
    ctx.shadowBlur = rr*0.4;

    ctx.beginPath();
    ctx.arc(px, py, rr, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();

    // Тонкая обводка
    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(1.5, rr*0.08);
    ctx.strokeStyle = `rgba(${base.r},${base.g},${base.b},0.3)`;
    ctx.stroke();

    // Блик
    const highlight = ctx.createRadialGradient(px - rr*0.3, py - rr*0.3, 0, px - rr*0.3, py - rr*0.3, rr*0.5);
    highlight.addColorStop(0, 'rgba(255,255,255,0.6)');
    highlight.addColorStop(0.6, 'rgba(255,255,255,0.2)');
    highlight.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = highlight;
    ctx.beginPath();
    ctx.arc(px - rr*0.25, py - rr*0.25, rr*0.45, 0, Math.PI*2);
    ctx.fill();

    // Буква
    ctx.globalCompositeOperation = 'source-over';
    const label = ((p && (p.emoji || p.name)) ? (p.emoji || p.name) : '').toString().trim();
    let letter = '•';
    if (label) {
      let isEmoji = false;
      // Без Unicode property escapes (в некоторых движках Edge это падает)
      const cp = label.codePointAt(0);
      // грубая эвристика: эмодзи/символы обычно выше U+2600 и особенно в U+1F000+
      isEmoji = (cp >= 0x1F000) || (cp >= 0x2600 && cp <= 0x27BF) || (label.length > 1 && cp >= 0x2000);

      letter = isEmoji ? label : (label[0]?.toUpperCase() || '•');
    }
    const glyph = letter;

// Размер глифа — делаем крупным, но чтобы не резало по кругу
const fontPx = Math.round(rr * 1.70); // bigger for single clusters
ctx.textAlign='center'; ctx.textBaseline='middle';

// Если "пустая морда" — рисуем круг в цвет пользователя
if (!glyph) {
  ctx.strokeStyle = ((p && p.color) ? p.color : DEFAULT_COLOR);
  ctx.lineWidth = Math.max(3, rr*0.18);
  ctx.beginPath();
  ctx.arc(px, py, Math.max(8, rr*0.55), 0, Math.PI*2);
  ctx.stroke();
} else {
  // Рисуем перекрашенный эмодзи без фона/квадрата
  const inactive = !!(
    (p && p.state && p.state !== 'online') ||
    (p && p.ts && (Date.now() - p.ts > 20000)) ||
    (p && p.lastActive && (Date.now() - p.lastActive > 10*60*1000))
  );
  if (inactive) {
    _drawTintedEmoji(ctx, glyph, px, py, fontPx, '#999999', {mono:true});
  } else {
    _drawTintedEmoji(ctx, glyph, px, py, fontPx, ((p && p.color) ? p.color : DEFAULT_COLOR), {brightness: 0.10, contrast: 1.18, outline: true, outlineWidth: Math.max(1, Math.round(fontPx*0.03))});
  }
}

ctx.restore();
}

  function drawFrame(){
    const now = performance.now();
    const dt = 0.016; // упрощённо

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // DEBUG код удален

    // strokes (PERF): не перерисовываем ВСЁ каждый кадр.
    // Собираем кэш только когда пришли новые штрихи/ластики/заливки или поменялся размер canvas.
    const dpr = window.devicePixelRatio||1;
    const W = canvas.width;
    const H = canvas.height;

    if (!state._strokesCache){
      state._strokesCache = document.createElement('canvas');
      state._strokesCacheCtx = state._strokesCache.getContext('2d');
      state._strokesDirty = true;
    }
    if (state._strokesCache.width !== W || state._strokesCache.height !== H){
      state._strokesCache.width = W; state._strokesCache.height = H;
      state._strokesDirty = true;
      // при ресайзе нужно и слои подогнать
      state._strokeLayers = state._strokeLayers || new Map();
    }

    if (state._strokesDirty){
      const ctxC = state._strokesCacheCtx;
      ctxC.setTransform(1,0,0,1,0,0);
      ctxC.clearRect(0,0,W,H);

      // Стабильная сортировка: сначала по времени, потом по uid
      const strokesSorted = (state._strokesSortedCache || [...state.strokes.values()].sort((a,b)=> {
        const timeDiff = (a.ts||0) - (b.ts||0);
        if (timeDiff !== 0) return timeDiff;
        return (a.uid||'').localeCompare(b.uid||'');
      }));
      state._strokesSortedCache = strokesSorted;

      // Группируем по uid
      const byUid = new Map();
      for (const s of strokesSorted){
        const uid = s.uid || 'anon';
        if (!byUid.has(uid)) byUid.set(uid, { draw: [], erase: [] });
        (s.erase ? byUid.get(uid).erase : byUid.get(uid).draw).push(s);
      }

      // Кэшируем offscreen canvases (по uid)
      state._strokeLayers = state._strokeLayers || new Map();
      function getLayer(uid){
        let layer = state._strokeLayers.get(uid);
        if (!layer){
          const c = document.createElement('canvas');
          c.width = W; c.height = H;
          layer = { c, ctx: c.getContext('2d') };
          state._strokeLayers.set(uid, layer);
        } else if (layer.c.width !== W || layer.c.height !== H){
          layer.c.width = W; layer.c.height = H;
        }
        return layer;
      }

      // Bucket fill (заливка) — выполняется при сборке кэша
      function _hexToRgba(hex){
        const h = (hex||'#000000').replace('#','');
        const r = parseInt(h.slice(0,2),16)||0, g=parseInt(h.slice(2,4),16)||0, b=parseInt(h.slice(4,6),16)||0;
        return [r,g,b,255];
      }
      function _floodFillOnCtx(ctx2, sx, sy, hex, opts){
        opts = opts || {};
        const overwriteStrokes = !!opts.overwriteStrokes;
        const w = ctx2.canvas.width, h = ctx2.canvas.height;
        sx = Math.floor(sx); sy = Math.floor(sy);
        if (sx<0||sy<0||sx>=w||sy>=h) return;
        const img = ctx2.getImageData(0,0,w,h);
        const d = img.data;
        const idx0 = (sy*w+sx)*4;
        const target = [d[idx0],d[idx0+1],d[idx0+2],d[idx0+3]];
        const repl = _hexToRgba(hex);
        if (target[0]===repl[0] && target[1]===repl[1] && target[2]===repl[2] && target[3]===repl[3]) return;

        const stack = [sx,sy];
        const tol = 26; // color tolerance (boosted to reduce fringe gaps)
        const aMin = 0; // include transparent pixels too
        const match = (i)=> {
          const dr = d[i]-target[0], dg=d[i+1]-target[1], db=d[i+2]-target[2], da=d[i+3]-target[3];
          return (Math.abs(dr)<=tol && Math.abs(dg)<=tol && Math.abs(db)<=tol && Math.abs(da)<=tol && d[i+3]>=aMin);
        };
        while(stack.length){
          const y = stack.pop(); const x = stack.pop();
          if (x<0||y<0||x>=w||y>=h) continue;
          const i = (y*w+x)*4;
          if (!match(i)) continue;
          d[i]=repl[0]; d[i+1]=repl[1]; d[i+2]=repl[2]; d[i+3]=255;
          stack.push(x+1,y, x-1,y, x,y+1, x,y-1);
        }

        // small dilation into fringe pixels
        const grow = 6;
        const filled = new Uint8Array(w*h);
        for (let yy=0; yy<h; yy++){
          for (let xx=0; xx<w; xx++){
            const ii = (yy*w+xx)*4;
            if (d[ii+3]===255 && d[ii]===repl[0] && d[ii+1]===repl[1] && d[ii+2]===repl[2]) filled[yy*w+xx]=1;
          }
        }
        for (let yy=0; yy<h; yy++){
          for (let xx=0; xx<w; xx++){
            if (!filled[yy*w+xx]) continue;
            for (let y2=Math.max(0,yy-grow); y2<=Math.min(h-1,yy+grow); y2++){
              for (let x2=Math.max(0,xx-grow); x2<=Math.min(w-1,xx+grow); x2++){
                const j = (y2*w+x2)*4;
                if (d[j+3] >= 252 && !overwriteStrokes) continue; // keep solid strokes unless asked to overwrite
                if (overwriteStrokes){
                  // paint over any non-transparent pixels near the filled region to kill "outline"
                  if (d[j+3] > 0){
                    d[j]=repl[0]; d[j+1]=repl[1]; d[j+2]=repl[2]; d[j+3]=255;
                  }
                  continue;
                }
                const dr = d[j]-target[0], dg=d[j+1]-target[1], db=d[j+2]-target[2];
                if (Math.abs(dr)<=tol*2 && Math.abs(dg)<=tol*2 && Math.abs(db)<=tol*2){
                  d[j]=repl[0]; d[j+1]=repl[1]; d[j+2]=repl[2]; d[j+3]=255;
                }
              }
            }
          }
        }
        ctx2.putImageData(img,0,0);
      }

      function drawStrokeTo(ctx2, s){
        if (s && s.fill){
          const p = pxFromNorm(s.x, s.y);
          _floodFillOnCtx(ctx2, p.x, p.y, s.color || DEFAULT_COLOR, { overwriteStrokes: true });
          return;
        }

        const pts = s.points || [];
        if (pts.length < 2) return;

        ctx2.save();
        ctx2.lineCap = 'round';
        ctx2.lineJoin = 'round';
        ctx2.lineWidth = (s.w || 4) * dpr;

        if (s.erase){
          ctx2.globalCompositeOperation = 'destination-out';
          ctx2.strokeStyle = 'rgba(0,0,0,1)';
        } else {
          ctx2.globalCompositeOperation = 'source-over';
          ctx2.strokeStyle = s.color || DEFAULT_COLOR;
        }

        ctx2.beginPath();
        let p0 = pxFromNorm(pts[0].x, pts[0].y);
        ctx2.moveTo(p0.x, p0.y);

        for (let i = 1; i < pts.length - 1; i++){
          const p1 = pxFromNorm(pts[i].x, pts[i].y);
          const p2 = pxFromNorm(pts[i+1].x, pts[i+1].y);
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          ctx2.quadraticCurveTo(p1.x, p1.y, midX, midY);
        }

        if (pts.length > 1){
          const last = pxFromNorm(pts[pts.length - 1].x, pts[pts.length - 1].y);
          ctx2.lineTo(last.x, last.y);
        }

        ctx2.stroke();
        ctx2.restore();
      }

      // Рендер слоёв 1 раз в кэш
      for (const [uid, grp] of byUid.entries()){
        const layer = getLayer(uid);
        const ctx2 = layer.ctx;

        ctx2.setTransform(1,0,0,1,0,0);
        ctx2.clearRect(0, 0, W, H);

        for (const s of grp.draw) drawStrokeTo(ctx2, s);
        for (const s of grp.erase) drawStrokeTo(ctx2, s);

        ctxC.drawImage(layer.c, 0, 0);
      }

      state._strokesDirty = false;
    }

    // Рисуем кэш штрихов
    if (state._strokesCache) ctx.drawImage(state._strokesCache, 0, 0);

    // Рисуем текущий штрих (живая отрисовка)
    if (state.currentStroke) {
      const s = state.currentStroke;
      const pts = s.points || [];
      if (pts.length >= 2) {
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = (s.w || 4) * dpr;

        if (s.erase) {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = s.color || DEFAULT_COLOR;
        }

        ctx.beginPath();
        let p0 = pxFromNorm(pts[0].x, pts[0].y);
        ctx.moveTo(p0.x, p0.y);

        for (let i = 1; i < pts.length - 1; i++) {
          const p1 = pxFromNorm(pts[i].x, pts[i].y);
          const p2 = pxFromNorm(pts[i + 1].x, pts[i + 1].y);
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
        }

        if (pts.length > 1) {
          const last = pxFromNorm(pts[pts.length - 1].x, pts[pts.length - 1].y);
          ctx.lineTo(last.x, last.y);
        }

        ctx.stroke();
        ctx.restore();
      }
    }

    // clusters
    if (isOverlayMode() || state.showClustersOnSite) {
    const clusters = computeClusters();
    const rot = now/1000 * 0.35;

    for (const c of clusters){
      const st = animStateFor(c.key, c);
      stepTowards(st, c, dt);

      const rr = st.r * (window.devicePixelRatio||1) * getRandomClusterScale(c.key, performance.now());
      const cx = st.x, cy = st.y;

      if (c.size === 1){
        const p = c.members[0];
        drawSingleDot(cx, cy, rr, p);
        continue;
      }

      // === СЕВЕРНОЕ СИЯНИЕ - ЦВЕТНЫЕ ВОЛНИСТЫЕ ЛИНИИ ===
      ctx.save();

      // 1. Мощное внешнее сияние (чем больше голосов, тем ярче)
      const glowIntensity = Math.min(1, 0.3 + c.size * 0.08);
      const glowRadius = rr * (1.5 + c.size * 0.05);
      const outerGlow = ctx.createRadialGradient(cx, cy, rr * 0.5, cx, cy, glowRadius);
      outerGlow.addColorStop(0.0, `rgba(255,255,255,${glowIntensity * 0.4})`);
      outerGlow.addColorStop(0.4, `rgba(220,240,255,${glowIntensity * 0.2})`);
      outerGlow.addColorStop(0.7, `rgba(180,220,255,${glowIntensity * 0.1})`);
      outerGlow.addColorStop(1.0, 'rgba(100,150,255,0)');
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = outerGlow;
      ctx.beginPath();
      ctx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      // 2. Яркое ядро
      const coreGrad = ctx.createRadialGradient(cx - rr * 0.25, cy - rr * 0.25, 0, cx, cy, rr * 0.95); // увеличил с 0.7 до 0.95
      coreGrad.addColorStop(0.0, 'rgba(255,255,255,1)');
      coreGrad.addColorStop(0.4, 'rgba(245,250,255,0.9)');
      coreGrad.addColorStop(0.8, 'rgba(200,225,255,0.5)');
      coreGrad.addColorStop(1.0, 'rgba(150,200,255,0.2)');
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = coreGrad;
      ctx.beginPath();
      ctx.arc(cx, cy, rr * 0.95, 0, Math.PI * 2); // увеличил с 0.7 до 0.95
      ctx.fill();

      // 3. ЦВЕТНЫЕ ВОЛНИСТЫЕ ЛИНИИ (главная фишка!)
      const palette = [...new Set(c.colors)];
      const numWaves = Math.min(12, palette.length * 3); // больше волн = больше красоты
      
      ctx.globalCompositeOperation = 'screen';
      
      for (let i = 0; i < numWaves; i++) {
        const t = now / 1000;
        const col = palette[i % palette.length];
        const { r: cr, g: cg, b: cb } = hexToRgb(col);
        
        // Параметры волны
        const waveSpeed = 0.3 + (i % 3) * 0.15;
        const waveFreq = 3 + (i % 4);
        const wavePhase = (i / numWaves) * Math.PI * 2;
        const baseRadius = rr * (0.35 + (i % 5) * 0.08);
        const waveAmplitude = rr * 0.12;
        
        // Рисуем волнистую линию
        ctx.save();
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},${0.7 + Math.sin(t * 2 + i) * 0.2})`;
        ctx.lineWidth = rr * (0.04 + Math.sin(t * 1.5 + i * 0.5) * 0.02);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Свечение линии
        ctx.shadowColor = `rgba(${cr},${cg},${cb},0.8)`;
        ctx.shadowBlur = rr * 0.15;
        
        ctx.beginPath();
        const segments = 80;
        for (let s = 0; s <= segments; s++) {
          const angle = (s / segments) * Math.PI * 2 + t * waveSpeed + wavePhase;
          const wave = Math.sin(s / segments * Math.PI * waveFreq + t * 3) * waveAmplitude;
          const radius = baseRadius + wave;
          const x = cx + Math.cos(angle) * radius;
          const y = cy + Math.sin(angle) * radius;
          
          if (s === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      // 4. Дополнительные яркие сияющие кольца
      ctx.globalCompositeOperation = 'screen';
      for (let ring = 0; ring < 3; ring++) {
        const ringAlpha = (Math.sin(now / 1000 * (1.2 + ring * 0.4)) * 0.5 + 0.5) * 0.3;
        const ringRad = rr * (0.6 + ring * 0.15);
        
        for (let i = 0; i < palette.length; i++) {
          const col = palette[i];
          const { r: cr, g: cg, b: cb } = hexToRgb(col);
          const angle = (i / palette.length) * Math.PI * 2 + now / 1000 * 0.5 + ring;
          const px = cx + Math.cos(angle) * ringRad;
          const py = cy + Math.sin(angle) * ringRad;
          
          const sparkle = ctx.createRadialGradient(px, py, 0, px, py, rr * 0.2);
          sparkle.addColorStop(0.0, `rgba(${cr},${cg},${cb},${ringAlpha})`);
          sparkle.addColorStop(0.5, `rgba(${cr},${cg},${cb},${ringAlpha * 0.5})`);
          sparkle.addColorStop(1.0, `rgba(${cr},${cg},${cb},0)`);
          ctx.fillStyle = sparkle;
          ctx.beginPath();
          ctx.arc(px, py, rr * 0.2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // 5. Тонкий контур - УБРАЛИ
      // ctx.globalCompositeOperation = 'source-over';
      // ctx.lineWidth = Math.max(1, rr * 0.02);
      // ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      // ctx.beginPath();
      // ctx.arc(cx, cy, rr * 0.95, 0, Math.PI * 2);
      // ctx.stroke();

      // 6. Число в центре
      ctx.globalCompositeOperation = 'source-over';
      const fontPx = Math.round(rr * 0.65);
      ctx.font = `900 ${fontPx}px 'Montserrat','Open Sans',sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#0a1520';
      ctx.shadowColor = 'rgba(255,255,255,0.9)';
      ctx.shadowBlur = Math.max(3, rr * 0.12);
      if (c.size === 1 && c.members && c.members[0]) {
        const m0 = c.members[0];
        const g0 = (m0.emoji || '').trim();
        const big = Math.round(rr * 2.05);
        if (!g0) {
          ctx.strokeStyle = (m0.color || DEFAULT_COLOR);
          ctx.lineWidth = Math.max(4, rr*0.2);
          ctx.beginPath();
          ctx.arc(cx, cy, Math.max(10, rr*0.65), 0, Math.PI*2);
          ctx.stroke();
        } else {
          ctx.font = `900 ${big}px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif`;
          // tinted emoji without square
          _drawTintedEmoji(ctx, g0, cx, cy, big, (m0.color || DEFAULT_COLOR), {brightness: 0.18, contrast: 1.15, outline: true, outlineWidth: Math.max(1, Math.round(big*0.03))});
        }
      } else {
        ctx.fillText(String(c.size), cx, cy);
      }

      // draw orbiting member emojis
      if (c.members && c.members.length) {
        const orbitR = rr * 0.95;
        const fontEm = Math.max(14, rr * 0.55);
        ctx.font = `900 ${Math.round(fontEm)}px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let i=0; i<c.members.length; i++) {
          const m = c.members[i];
          const a = rot + (i * Math.PI * 2 / c.members.length);
          const ex = cx + Math.cos(a) * orbitR;
          const ey = cy + Math.sin(a) * orbitR;
          const emo = (m.emoji || '').trim();
          if (!emo) continue;
          ctx.shadowColor = (m.color || DEFAULT_COLOR);
          ctx.shadowBlur = Math.max(4, rr * 0.18);
          // tinted emoji without square
          _drawTintedEmoji(ctx, emo, ex, ey, fontEm, (m.color || DEFAULT_COLOR));
        }
      }

      
      ctx.restore();
    }
    }

  // ===== Brush / Eraser cursor preview =====
  if (state.cursor && (state.cursor.tool === 'draw' || state.cursor.tool === 'erase')) {
    const dpr = window.devicePixelRatio || 1;
    const cp = pxFromNorm(state.cursor.x, state.cursor.y);
    const radius = Math.max(2, (state.cursor.w || 8) * dpr / 2);

    ctx.save();
    ctx.globalCompositeOperation = 'source-over';

    if (state.cursor.tool === 'draw') {
      // выбранный цвет, лёгкое свечение, полупрозрачный fill
      const col = state.cursor.color || DEFAULT_COLOR;
      ctx.shadowColor = col;
      ctx.shadowBlur = Math.max(6, radius * 0.35);

      // fill
      ctx.fillStyle = col + '22'; // ~13% alpha (hex)
      ctx.beginPath();
      ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
      ctx.fill();

      // outline светлее
      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(1, Math.round(radius * 0.10));
      ctx.strokeStyle = lightenHex(col, 0.35);
      ctx.beginPath();
      ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // eraser: без цвета, без свечения, контур чёрный, fill прозрачный
      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(1, Math.round(radius * 0.12));
      ctx.strokeStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath();
      ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }


  }
  // ===== RAF LOOP (perf): throttle on non-overlay + pause on hidden tab =====
  let __lastFrameTs = 0;
  const __fps = isOverlayMode() ? 60 : 20; // overlay needs smooth anim; site can be lighter
  const __frameInterval = 1000 / __fps;

  document.addEventListener('visibilitychange', () => {
    // force immediate redraw when tab becomes visible
    if (!document.hidden) __lastFrameTs = 0;
  });

  function loop(ts){
    // when tab is hidden, don't waste CPU
    if (document.hidden){
      requestAnimationFrame(loop);
      return;
    }
    if (__lastFrameTs && (ts - __lastFrameTs) < __frameInterval){
      requestAnimationFrame(loop);
      return;
    }
    __lastFrameTs = ts;
    drawFrame();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);


  /* ======= INPUT (vote/draw/erase) - ОТКЛЮЧЕНО ДЛЯ OVERLAY РЕЖИМА ======= */
  canvas.addEventListener('pointerdown', async (e)=>{
    // Хост (overlay) не может голосовать/рисовать
    if (isOverlayMode()) return;
    
    if (!state.authed) return;
    // /kick mode: клик по оффлайн морде удаляет её (только одна за команду)
    if (state.kickMode){
      e.preventDefault();
      const pos = normFromEvent(e);
      const now = Date.now();
      // ищем ближайшую морду в радиусе
      let bestUid=null, bestD=1e9, bestP=null;
      for (const [uid,p] of state.points.entries()){
        if (!p) continue;
        const dx = (p.x||0) - pos.x; const dy = (p.y||0) - pos.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD){ bestD=d2; bestUid=uid; bestP=p; }
      }
      const hit = (bestUid && bestP && bestD <= (0.035*0.035));
      if (!hit) { state.kickMode = false; return; }
      // теперь можно удалять ЛЮБУЮ морду (онлайн/оффлайн/свою)
      try{ await remove(ref(db, `${basePath}/points/${bestUid}`)); }catch{}
      state.points.delete(bestUid);
      state.kickMode = false;
      return;
    }
    if (state.tool==='vote'){
      e.preventDefault();
      const uid = auth.currentUser?.uid || state.id;
      const pos=normFromEvent(e);
      const p={ id:uid, name: getDisplayName(state)||'Чужой', x:pos.x, y:pos.y, ts:Date.now(), lastActive: Date.now(), color:state.color, emoji: state.emoji || '' };
      state.points.set(uid, p);
      try { await set(ref(db, `${basePath}/points/${uid}`), p); } catch {}
      return;
    }
    if (state.tool==='fill'){
      e.preventDefault();
      const uid = auth.currentUser?.uid || state.id;
      const pos = normFromEvent(e);
      const fillStroke = { uid, fill:true, x:pos.x, y:pos.y, color: state.color, ts:Date.now() };
      try{
        const key = push(strokesRoot).key;
        await update(ref(db, `${basePath}/strokes/${key}`), fillStroke);
      }catch{}
      return;
    }
    if (state.tool==='pick' && state.artEnabled){
      e.preventDefault();
      try{
        // Сэмплим цвет с результирующего холста
        const ppx = pxFromNorm(normFromEvent(e).x, normFromEvent(e).y);
        const img = ctx.getImageData(Math.max(0,Math.min(canvas.width-1, ppx.x)), Math.max(0,Math.min(canvas.height-1, ppx.y)), 1, 1).data;
        const hex = '#' + [img[0],img[1],img[2]].map(v=>v.toString(16).padStart(2,'0')).join('');
        state.color = hex;
        const picker = document.getElementById('artColorPicker');
        if (picker) picker.value = hex;
        const dot = document.getElementById('artColorDot');
        if (dot) dot.style.background = hex;
        try{ await heartbeat(); }catch{}
      }catch{}
      if (window.__ccPickDisarm) window.__ccPickDisarm();
      state.tool = 'draw';
      setActiveToolButtons?.();
      return;
    }
    if (state.tool==='draw' || state.tool==='erase'){
      e.preventDefault(); beginStroke(e, state.tool==='erase');
    }
  });

  let drawing=false; let currStroke=null;
  let PEN_WIDTH=4;        // ИЗМЕНЯЕМЫЙ размер кисти
  let ERASE_WIDTH=20;     // ИЗМЕНЯЕМЫЙ размер ластика
  const MIN_WIDTH=1, MAX_PEN_WIDTH=20, MAX_ERASE_WIDTH=50;
  
  // Элементы управления размером
  const brushSizeSlider = document.getElementById('brushSizeSlider');
  const brushSizeValue = document.getElementById('brushSizeValue');
  
  // Обновление размера при изменении слайдера
  brushSizeSlider.addEventListener('input', (e) => {
    const size = parseInt(e.target.value);
    if (state.tool === 'draw') {
      PEN_WIDTH = size;
      brushSizeValue.textContent = size + 'px';
    } else if (state.tool === 'erase') {
      ERASE_WIDTH = size;
      brushSizeValue.textContent = size + 'px';
    }
  });
  function beginStroke(e, erase=false){
    drawing=true;
    const p=normFromEvent(e);
    const uid=(auth.currentUser&&auth.currentUser.uid)||state.id;
    const width = erase ? ERASE_WIDTH : PEN_WIDTH; // Используем текущий размер
    currStroke={ uid, name: getDisplayName(state)||'Чужой', color:state.color, erase, w: width, points:[p], ts:Date.now(), _smooth:p, _lastRaw:p };
    state.currentStroke = currStroke; // Сохраняем в state для отрисовки
  }
  
function moveStroke(e){
    if(!drawing||!currStroke) return;
    const raw = normFromEvent(e);

    // Арт-режим: ровная линия по Shift (сохраняем только start + current)
    if (state.artEnabled && window.__ccShiftDown && window.__ccShiftDown()){
      const start = currStroke.points[0] || raw;
      currStroke.points = [start, raw];
      state.currentStroke = currStroke;
      return;
    }

    // --- Усиленная стабилизация (и для кисти, и для ластика) ---
    const prev = currStroke._smooth || currStroke.points[currStroke.points.length-1] || raw;

    // Чем меньше alpha, тем сильнее "задержка" и плавнее линия
    const alpha = (currStroke.erase ? 0.22 : 0.28);

    // Сглаженная точка (low-pass)
    const p = {
      x: prev.x + (raw.x - prev.x) * alpha,
      y: prev.y + (raw.y - prev.y) * alpha
    };
    currStroke._smooth = p;
    currStroke._lastRaw = raw;

    // Не добавляем точки слишком часто (убираем дрожь/углы)
    const last = currStroke.points[currStroke.points.length-1] || p;
    const dx = p.x - last.x, dy = p.y - last.y;
    const minDist = 0.0016; // в нормализованных координатах (~1-2px на 1200px ширины)
    if (dx*dx + dy*dy < minDist*minDist) {
      state.currentStroke = currStroke;
      return;
    }

    currStroke.points.push(p);
    state.currentStroke = currStroke;
  }
  
  // Убрал drawLiveStroke - теперь рисуем в основном цикле
  async function endStroke(){
    if(!drawing||!currStroke) return;    // Ластик теперь работает как "нормальный": мы сохраняем erase-штрих и отрисовываем его через destination-out,
    // поэтому он стирает только там, где ты провела ластиком, не удаляя целиком линию (и уж точно не задевая соседние).
    try{
      const key = push(strokesRoot).key;
      await update(ref(db, `${basePath}/strokes/${key}`), currStroke);
    }catch{}
    
    drawing=false; currStroke=null;
    state.currentStroke = null; // Очищаем текущий штрих
  }
  canvas.addEventListener('pointermove', (e)=>{ 
    // Курсор кисти/ластика: прозрачный кружок размера инструмента
    try{
      const np = normFromEvent(e);
      const w = (state.tool==='erase') ? ERASE_WIDTH : PEN_WIDTH;
      state.cursor = { x: np.x, y: np.y, tool: state.tool, w, color: state.color };
    }catch{}
    if(state.tool==='draw'||state.tool==='erase') moveStroke(e); 
  });
  window.addEventListener('pointerup', endStroke);
  window.addEventListener('pointercancel', endStroke);
  canvas.addEventListener('pointerleave', ()=>{ state.cursor=null; });
  
  // Отключаем скролл на canvas и чате (мобильные)
  canvas.addEventListener('touchstart', e => e.preventDefault(), {passive: false});
  canvas.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
  chatPanel.addEventListener('touchstart', e => e.stopPropagation());
  chatPanel.addEventListener('touchmove', e => e.stopPropagation());

  /* ======= DRAGGABLE CHAT (с поддержкой тачскрина) ======= */
  (function enableDrag(){
    let startX=0, startY=0, baseLeft=chatPanel.offsetLeft, baseTop=chatPanel.offsetTop, dragging=false;
    const saved=localStorage.getItem('cc_chat_pos'); 
    if(saved){ 
      try{
        const {left,top}=JSON.parse(saved); 
        chatPanel.style.left=left+'px'; 
        chatPanel.style.top=top+'px';
      }catch{} 
    }
    
    function onDown(e){ 
      e.preventDefault();
      dragging=true; 
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      startX=clientX; 
      startY=clientY; 
      baseLeft=chatPanel.offsetLeft; 
      baseTop=chatPanel.offsetTop; 
      document.addEventListener('pointermove', onMove); 
      document.addEventListener('pointerup', onUp); 
      document.addEventListener('touchmove', onMove, {passive: false});
      document.addEventListener('touchend', onUp);
    }
    
    function onMove(e){ 
      if(!dragging) return; 
      e.preventDefault();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const dx=clientX-startX, dy=clientY-startY; 
      let l=baseLeft+dx, t=baseTop+dy; 
      const margin=6; 
      l=Math.max(margin, Math.min(window.innerWidth - chatPanel.offsetWidth - margin, l)); 
      t=Math.max(margin, Math.min(window.innerHeight - chatPanel.offsetHeight - margin, t)); 
      chatPanel.style.left=l+'px'; 
      chatPanel.style.top=t+'px'; 
    }
    
    function onUp(){ 
      dragging=false; 
      document.removeEventListener('pointermove', onMove); 
      document.removeEventListener('pointerup', onUp); 
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onUp);
      localStorage.setItem('cc_chat_pos', JSON.stringify({ 
        left: chatPanel.offsetLeft, 
        top: chatPanel.offsetTop 
      })); 
    }
    
    chatDragHandle.addEventListener('pointerdown', onDown);
  })();

  
/* ======= ART MODE (локально, по /art) ======= */
(function(){
  let artEnabled = false;
  let shiftDown = false;
  let pickArmed = false;

  const toolFill = document.getElementById('toolFill');
  const toolPick = document.getElementById('toolPick');
  const artColorDot = document.getElementById('artColorDot');
  const artColorPicker = document.getElementById('artColorPicker');

  function lighten(hex, amt=0.35){
    try{
      const c = hex.replace('#','');
      const r = parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16);
      const lr = Math.min(255, Math.round(r + (255-r)*amt));
      const lg = Math.min(255, Math.round(g + (255-g)*amt));
      const lb = Math.min(255, Math.round(b + (255-b)*amt));
      return '#' + [lr,lg,lb].map(v=>v.toString(16).padStart(2,'0')).join('');
    }catch{ return hex; }
  }

  function applyArtUI(){
    if (toolFill) toolFill.style.display = ''; // bucket available for everyone
    if (toolPick) toolPick.style.display = artEnabled ? '' : 'none';
    if (artColorDot) artColorDot.style.display = artEnabled ? '' : 'none';
    if (artColorPicker) artColorPicker.style.display = 'none';

    if (artColorDot){
      artColorDot.style.background = state.color || '#16c7b7';
      const glow = lighten(state.color || '#16c7b7', 0.35);
      artColorDot.style.boxShadow = artEnabled ? `0 0 0 2px ${glow}55, 0 0 14px ${glow}55` : '';
    }
  }

  window.toggleArtMode = function(){
    artEnabled = !artEnabled;
    state.artEnabled = artEnabled;
    // В арт-режиме инструменты рисования доступны, но не принудительно включаем
    // Просто показываем доп.кнопки и даём новые фичи
    applyArtUI();
  };

  // Цвет в арт-режиме (кружок)
  if (artColorDot && artColorPicker){
    artColorDot.addEventListener('click', ()=> artColorPicker.click());
    artColorPicker.addEventListener('input', async ()=>{
      state.color = artColorPicker.value;
      if (window.__neoApplyAccent) window.__neoApplyAccent(state.color);
      applyArtUI();
      // Обновим presence, чтобы цвет разошёлся всем (если нужно)
      try{ await heartbeat(); }catch{}
    });
  }

  // Кнопки инструментов
  if (toolFill){
    toolFill.addEventListener('click', ()=>{
      state.tool = 'fill';
      setActiveToolButtons?.();
    });
  }
  if (toolPick){
    toolPick.addEventListener('click', ()=>{
      if (!state.artEnabled) return;
      state.tool = 'pick';
      pickArmed = true;
      setActiveToolButtons?.();
    });
  }

  // Shift для ровных линий
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Shift') shiftDown = true; });
  window.addEventListener('keyup', (e)=>{ if (e.key === 'Shift') shiftDown = false; });
  window.__ccShiftDown = ()=>shiftDown;
  window.__ccPickArmed = ()=>pickArmed;
  window.__ccPickDisarm = ()=>{ pickArmed = false; };
  window.__ccArtEnabled = ()=>artEnabled;

  // Первый рендер UI
  applyArtUI();
})();
/* ======= STARTUP ======= */
  if (state.localChat.length){ renderChat(state.localChat.slice(-100)); }

  const url = new URL(FIXED_VIEW);
  if(!url.searchParams.get('cleanoutput')) url.searchParams.set('cleanoutput','1');
  if(!url.searchParams.get('stats')) url.searchParams.set('stats','0');
  if (!isOverlayMode()) $player.src = url.toString();

  setTool(state.tool || 'vote');
  
  /* ============= TELEGRAM ПРИВЯЗКА ============= */
  
  // Генерация случайного кода привязки
  function generateLinkCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = 'LINK-';
    for (let i = 0; i < 4; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }
  
  // Проверка привязки при загрузке
  async function checkTelegramLink() {
    if (!auth.currentUser) return null;
    
    try {
      const linksRef = ref(db, `${basePath}/telegram_links/${state.id}`);
      const snapshot = await get(linksRef);
      
      if (snapshot.exists()) {
        const linkData = snapshot.val();
        console.log('✅ Аккаунт привязан к Telegram:', linkData);
        return linkData;
      }
    } catch (e) {
      console.error('Ошибка проверки привязки:', e);
    }
    
    return null;
  }
  
  // Обновление UI кнопки привязки
  function updateLinkButton(linkData) {
    const linkBtn = document.getElementById('linkTelegramBtn');
    if (!linkBtn) return;
    
    if (linkData) {
      linkBtn.innerHTML = '✅ TG';
      linkBtn.classList.add('linked');
      linkBtn.title = `Привязан к @${linkData.tgUsername || linkData.tgFirstName}`;
    } else {
      linkBtn.innerHTML = '📎';
      linkBtn.classList.remove('linked');
      linkBtn.title = 'Связать с Telegram';
    }
  }
  
  // Создание кода привязки в Firebase
  async function createLinkCode() {
    if (!auth.currentUser) {
      alert('Сначала войди на сайт!');
      return null;
    }
    
    const code = generateLinkCode();
    const codeData = {
      userId: state.id,
      name: getDisplayName(state) || 'Чужой',
      color: state.color,
      createdAt: Date.now(),
      expiresAt: Date.now() + (5 * 60 * 1000), // 5 минут
      used: false
    };
    
    try {
      const codesRef = ref(db, `${basePath}/link_codes/${code}`);
      await set(codesRef, codeData);
      console.log('✅ Код создан:', code);
      return code;
    } catch (e) {
      console.error('❌ Ошибка создания кода:', e);
      return null;
    }
  }
  
  // Показать модальное окно привязки
  window.showLinkModal = async function() {
    const modal = document.getElementById('linkModal');
    modal.classList.add('show');
    const linkCodeEl = document.getElementById('linkCode');
    const linkInfo = document.getElementById('linkInfo');
    const linkNewBtn = document.getElementById('linkNewCodeBtn');
    const unlinkBtn = document.getElementById('unlinkBtn');
    
    // Проверяем текущую привязку
    const currentLink = await checkTelegramLink();
    
    if (currentLink) {
      // Уже привязан - показываем информацию
      linkInfo.classList.remove('hidden');
      linkCodeEl.parentElement.classList.add('hidden');
      linkNewBtn.classList.add('hidden');
      unlinkBtn.classList.remove('hidden');
      
      document.getElementById('linkInfoName').textContent = currentLink.tgFirstName;
      document.getElementById('linkInfoUsername').textContent = 
        currentLink.tgUsername ? `@${currentLink.tgUsername}` : 'Не указан';
      
      const linkedDate = new Date(currentLink.linkedAt);
      document.getElementById('linkInfoDate').textContent = 
        linkedDate.toLocaleDateString('ru-RU') + ' ' + linkedDate.toLocaleTimeString('ru-RU');
    } else {
      // Не привязан - генерируем код
      linkInfo.classList.add('hidden');
      linkCodeEl.parentElement.classList.remove('hidden');
      linkNewBtn.classList.remove('hidden');
      unlinkBtn.classList.add('hidden');
      
      const code = await createLinkCode();
      if (code) {
        linkCodeEl.textContent = '/link ' + code;
      } else {
        linkCodeEl.textContent = 'Ошибка';
      }
    }
    
    modal.classList.add('show');
  }
  
  // Закрыть модальное окно
  
  // Открыть бота Telegram в новой вкладке
  window.openTelegramBot = function(){
    try{
      window.open('https://t.me/DepressivePasties_bot', '_blank', 'noopener');
    }catch(e){
      // ignore
    }
  }
window.closeLinkModal = function() {
    const modal = document.getElementById('linkModal');
    modal.classList.remove('show');
  }
  
  // Копировать код
  window.copyLinkCode = function() {
    const linkCodeEl = document.getElementById('linkCode');
    const code = linkCodeEl.textContent;
    
    navigator.clipboard.writeText(code).then(() => {
      const originalText = linkCodeEl.textContent;
      linkCodeEl.textContent = '✓ Скопировано!';
      linkCodeEl.style.color = '#22c55e';
      
      setTimeout(() => {
        linkCodeEl.textContent = originalText;
        linkCodeEl.style.color = '';
      }, 2000);
    }).catch(err => {
      alert('Ошибка копирования. Скопируй вручную: ' + code);
    });
  }
  
  // Функция вызова панели эмодзи (для Python)
  window.toggleEmojiPanel = function() {
    const panel = document.getElementById('overlayEmojiPanel');
    if (!panel) return false;
    
    if (panel.innerHTML.trim() === "") {
      const bar = document.getElementById('reactionsBar');
      if (bar) {
        panel.innerHTML = bar.innerHTML;
        const hotkeys = ['Q','W','E','R','T','A','S','D','F','G','Z','X','C','V','B'];
        panel.querySelectorAll('button').forEach((btn, index) => {
          btn.removeAttribute('id');
          if (hotkeys[index]) btn.title = `Alt + ${hotkeys[index]}`;
          
          btn.onclick = () => {
            const type = btn.getAttribute('data-reaction-type');
            const emo = btn.getAttribute('data-emo');
            const src = btn.getAttribute('data-reaction-src');
            const key = btn.getAttribute('data-reaction-key');

            // ОТПРАВКА в базу
            if (type === 'png') {
              if (typeof sendReaction === 'function') sendReaction({ type: 'png', src, key });
              // ЛОКАЛЬНЫЙ ПОЛЕТ (визуально для тебя)
              if (window.createFlyingEmoji) window.createFlyingEmoji(src, true);
            } else {
              const char = emo || btn.textContent;
              if (typeof sendReaction === 'function') sendReaction(char);
              // ЛОКАЛЬНЫЙ ПОЛЕТ
              if (window.createFlyingEmoji) window.createFlyingEmoji(char, false);
            }
          };
        });
      }
    }
    return panel.classList.toggle('show');
  };

  // Исправленный обработчик хоткеев
  window.overlayHotkey = function(idx) {
    const bar = document.getElementById('reactionsBar');
    if (!bar) return;
    const btns = bar.querySelectorAll('button');
    // ВАЖНО: проверяем индекс (Python пришлет 0 для первой кнопки)
    if (btns[idx]) {
        btns[idx].click();
    }
  };
    


  // Отвязать Telegram
  window.unlinkTelegram = async function() {
    if (!confirm('Отвязать Telegram аккаунт?')) return;
    
    try {
      const linksRef = ref(db, `${basePath}/telegram_links/${state.id}`);
      await remove(linksRef);
      
      alert('✅ Telegram отвязан!');
      closeLinkModal();
      updateLinkButton(null);
      
      console.log('✅ Отвязка выполнена');
    } catch (e) {
      console.error('❌ Ошибка отвязки:', e);
      alert('Ошибка при отвязке. Попробуй ещё раз.');
    }
  }
  
  // Генерировать новый код
  window.generateNewCode = async function() {
    const linkCodeEl = document.getElementById('linkCode');
    linkCodeEl.textContent = 'Генерация...';
    
    const code = await createLinkCode();
    if (code) {
      linkCodeEl.textContent = '/link ' + code;
    } else {
      linkCodeEl.textContent = 'Ошибка';
    }
  }
  
  // Слушатель изменений привязки (реалтайм обновление)
  function listenToLinkChanges() {
    if (!auth.currentUser) return;
    
    const linksRef = ref(db, `${basePath}/telegram_links/${state.id}`);
    
    onValue(linksRef, async (snapshot) => {
      if (snapshot.exists()) {
        const linkData = snapshot.val();
        updateLinkButton(linkData);
        
        // Если модалка открыта с кодом - закрываем её и показываем успех
        const modal = document.getElementById('linkModal');
        const linkCodeEl = document.getElementById('linkCode');
        
        if (modal.classList.contains('show') && 
            linkCodeEl.textContent.includes('LINK-')) {
          closeLinkModal();
          
          // Показываем уведомление
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(34, 197, 94, 0.4);
            z-index: 10000;
            font-weight: 700;
            animation: slideIn 0.3s ease;
          `;
          notification.innerHTML = `
            ✅ Telegram успешно привязан!<br>
            <span style="font-size: 0.9em; opacity: 0.9;">@${linkData.tgUsername || linkData.tgFirstName}</span>
          `;
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => notification.remove(), 300);
          }, 4000);
        }
      } else {
        updateLinkButton(null);
      }
    });
  }
  
  // Инициализация Telegram привязки
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      // Проверяем привязку
      const linkData = await checkTelegramLink();
      updateLinkButton(linkData);
      
      // Запускаем слушатель
      listenToLinkChanges();
    }
  });
  
  // Анимации для уведомлений
  const telegramAnimStyle = document.createElement('style');
  telegramAnimStyle.textContent = `
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes slideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100px);
      }
    }
  `;
  document.head.appendChild(telegramAnimStyle);
  
    // Сохранение
  function saveEmojiToDb(index, newValue) {
    if (!auth.currentUser) return;
    // нормализуем массив до нужной длины
    if (!Array.isArray(userEmojis)) userEmojis = [];
    while (userEmojis.length <= index) userEmojis.push('');
    userEmojis[index] = newValue;

    // RTDB лучше хранить как массив через set на child-путь, а читать уметь и объектом тоже
    const emojiRef = ref(db, `${basePath}/users/${auth.currentUser.uid}/settings/emojis`);
    set(emojiRef, userEmojis).then(()=>{ try{ applyUserEmojis(); }catch{} }).catch(()=>{});
  }

  // Вешаем правый клик на все кнопки при загрузке
  document.querySelectorAll('[id^="emoBtn_"]').forEach((btn, i) => {
    btn.oncontextmenu = (e) => {
      e.preventDefault();
      const current = btn.getAttribute('data-emo');
      const newValue = prompt("Изменить эмодзи/текст:", current);
      if (newValue !== null && newValue !== "") {
        saveEmojiToDb(i, newValue);
      }
    };
  });

  // Для Python: нажал Alt+1..15 -> вылетела реакция
  window.overlayHotkey = function(idx) {
      const bar = document.getElementById('reactionsBar');
      if (!bar) return;
      
      const btns = bar.querySelectorAll('button');
      const btn = btns[idx];
      if (btn) {
          // 1. Кликаем по кнопке (отправка в базу)
          btn.click(); 

          // 2. Ищем, как на твоем сайте называется функция полета
          // Обычно это createFlyingEmoji, spawnEmoji или что-то похожее
          const flyFunc = window.createFlyingEmoji || window.spawnEmoji || window.addEmoji;
          
          if (typeof flyFunc === 'function') {
              const type = btn.getAttribute('data-reaction-type');
              const emo = btn.getAttribute('data-emo');
              const src = btn.getAttribute('data-reaction-src');
              
              if (type === 'png' || src) {
                  // Если картинка (PNG)
                  flyFunc(src || btn.querySelector('img').src, true);
              } else {
                  // Если текст (Emoji)
                  flyFunc(emo || btn.textContent, false);
              }
          } else {
              console.log("ОШИБКА: Функция полета не найдена. Проверь название в index.html");
          }
      }
  };
</script>

<!-- Модальное окно привязки Telegram -->
<div class="link-modal" id="linkModal" onclick="if(event.target===this) closeLinkModal()">
  <div class="link-modal-content">
    <h3>🔗 Связать с Telegram</h3>
    
    <!-- Если НЕ привязан - показываем код -->
    <div id="linkCodeSection">
      <p>
        Отправь этот код боту в личные сообщения:
      </p>
      
      <div class="link-code" id="linkCode" onclick="copyLinkCode()">
        /link LINK-XXXX
      </div>
      
      <p class="link-hint">
        💡 Код действителен 5 минут<br>
        🔄 Кликни на код, чтобы скопировать
      </p>
      
      <div class="link-modal-buttons">
        <button class="btn small" id="toBotBtn" onclick="openTelegramBot()">🤖</button>
        <button class="btn ghost small" id="linkNewCodeBtn" onclick="generateNewCode()">🔄 Новый код</button>
        <button class="btn ghost small" onclick="closeLinkModal()">Закрыть</button>
      </div>
    </div>
    
    <!-- Если УЖЕ привязан - показываем информацию -->
    <div id="linkInfo" class="link-info hidden">
      <div style="text-align: center; margin-bottom: 16px;">
        <span class="link-status linked">✅ Привязан</span>
      </div>
      
      <div class="link-info-row">
        <span class="link-info-label">👤 Имя:</span>
        <span class="link-info-value" id="linkInfoName">—</span>
      </div>
      
      <div class="link-info-row">
        <span class="link-info-label">📱 Username:</span>
        <span class="link-info-value" id="linkInfoUsername">—</span>
      </div>
      
      <div class="link-info-row">
        <span class="link-info-label">📅 Привязано:</span>
        <span class="link-info-value" id="linkInfoDate">—</span>
      </div>
      
      <div class="link-modal-buttons" style="margin-top: 20px;">
        <button class="btn danger small" id="unlinkBtn" onclick="unlinkTelegram()">
          🔓 Отвязать
        </button>
        <button class="btn ghost small" onclick="closeLinkModal()">Закрыть</button>
      </div>
    </div>
  </div>
</div>



<div id="overlayEmojiPanel" class="overlay-emoji-panel"></div>


<script>
/* ===== GATE EMOJI PICKER (NO-MODULE, WORKS EVEN IF MODULE IMPORTS FAIL) ===== */
(function(){
  if (window.__emojiPickerBooted) return;
  window.__emojiPickerBooted = true;

  
/* ===== TINTED EMOJI (GLOBAL FOR GATE PREVIEW) =====
   Gate preview uses this helper to match cluster rendering.
   If the main renderer already defined it, keep existing. */
if (typeof window._drawTintedEmoji !== 'function') {
  window._hexToRgb = window._hexToRgb || function(hex){
    if(!hex) return {r:0,g:0,b:0};
    hex = (''+hex).trim();
    if(hex[0]==='#') hex=hex.slice(1);
    if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const n = parseInt(hex,16);
    return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
  };

  window._isGrayRGB = window._isGrayRGB || function(rgb, tol=2){
    return Math.abs(rgb.r-rgb.g)<=tol && Math.abs(rgb.g-rgb.b)<=tol;
  };

  // Draw emoji into ctx at (x,y) baseline center with sizePx, tinted to hexColor using filter pipeline.
  window._drawTintedEmoji = function(ctx, emoji, x, y, sizePx, hexColor, opts){
    opts = opts || {};
    if (!emoji) return;

    const rgb = window._hexToRgb(hexColor);
    const gray = window._isGrayRGB(rgb, 2);

    // Convert chosen color to hue for hue-rotate()
    // (For grayscale colors we disable sepia + hue-rotate to preserve true gray differences.)
    const toHue = (r,g,b)=>{
      r/=255; g/=255; b/=255;
      const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
      const d=mx-mn;
      let h=0;
      if (d===0) h=0;
      else if (mx===r) h=((g-b)/d)%6;
      else if (mx===g) h=((b-r)/d)+2;
      else h=((r-g)/d)+4;
      h=Math.round(h*60);
      if (h<0) h+=360;
      return h;
    };
    const targetHue = gray ? 0 : toHue(rgb.r, rgb.g, rgb.b);

    // Offscreen canvas (small and cached per call; fast enough for our use)
    const off = document.createElement('canvas');
    const pad = Math.ceil(sizePx*0.7);
    off.width = off.height = Math.ceil(sizePx + pad*2);
    const octx = off.getContext('2d');

    octx.clearRect(0,0,off.width,off.height);
    octx.textAlign = 'center';
    octx.textBaseline = 'middle';
    octx.font = `${Math.floor(sizePx)}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",sans-serif`;

    const brightness = (opts.brightness ?? 0.95);
    const contrast   = (opts.contrast ?? 1.05);
    const sepiaAmt   = gray ? 0 : (opts.sepia ?? 1);
    const satAmt     = gray ? 1 : (opts.saturate ?? 1.35);

    // Key: draw the emoji itself and let the filter pipeline do the "pseudo-recolor".
    // This preserves internal gradients/shading and avoids square backgrounds.
    octx.filter = `grayscale(1) sepia(${sepiaAmt}) saturate(${satAmt}) hue-rotate(${targetHue}deg) brightness(${brightness}) contrast(${contrast})`;
    // Do NOT force fillStyle to black; keep emoji's own color layers.
    octx.fillText(emoji, off.width/2, off.height/2);
    octx.filter = 'none';

    // Optional outline (soft) – for gate preview and single dots
    if (opts.outline){
      const lw = opts.outlineWidth ?? 2;
      const alpha = opts.outlineAlpha ?? 0.6;

      // outline color: a bit lighter than chosen color (or black for grayscale)
      let or = gray ? 0 : Math.min(255, Math.round(rgb.r + (255-rgb.r)*0.35));
      let og = gray ? 0 : Math.min(255, Math.round(rgb.g + (255-rgb.g)*0.35));
      let ob = gray ? 0 : Math.min(255, Math.round(rgb.b + (255-rgb.b)*0.35));

      // For grayscale colors, use darker outline for visibility
      if (gray){
        or = og = ob = 0;
      }

      // Draw outline by stamping the emoji around (cheap + looks good)
      const ox = off.width/2, oy = off.height/2;
      const stamp = (dx,dy)=>{
        octx.save();
        octx.globalAlpha = alpha;
        octx.filter = `grayscale(1) sepia(${sepiaAmt}) saturate(${satAmt}) hue-rotate(${targetHue}deg) brightness(${Math.min(1.15, brightness+0.08)}) contrast(${Math.max(1.05, contrast)})`;
        octx.translate(dx,dy);
        octx.fillText(emoji, ox, oy);
        octx.restore();
      };
      for (let a=0;a<8;a++){
        const ang = a*Math.PI/4;
        stamp(Math.cos(ang)*lw, Math.sin(ang)*lw);
      }
      // Re-draw main on top
      octx.save();
      octx.filter = `grayscale(1) sepia(${sepiaAmt}) saturate(${satAmt}) hue-rotate(${targetHue}deg) brightness(${brightness}) contrast(${contrast})`;
      octx.fillText(emoji, ox, oy);
      octx.restore();
    }

    ctx.drawImage(off, x - off.width/2, y - off.height/2);
  };
}


// === gate helper: gray check (used for disabling sepia/hue for grayscale colors) ===
function isGray(rgb){
  return !!rgb && rgb.r === rgb.g && rgb.g === rgb.b;
}

function boot(){
    const gateColor = document.getElementById('gateColor');
    const emojiGrid = document.getElementById('emojiGrid');
    const emojiDisplay = document.getElementById('emojiDisplay');
    const gateHint = document.getElementById('gateHint');

    if (!gateColor || !emojiGrid || !emojiDisplay) return;

    const emojis = [
      null,
      '🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨',
      '🐯','🦁','🐮','🐷','🐸','🐵','🦉','🐺','🦀','🦝'
    ];

    let selected = localStorage.getItem('cc_emoji');
    // null/empty means "no face"
    if (selected === null) selected = '🐶';
    try { window.dispatchEvent(new CustomEvent('cc_emoji_changed', { detail: { emoji: selected } })); } catch {}

    function renderGrid(){
      emojiGrid.innerHTML = '';
      emojis.forEach((emo)=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'emoji-btn';
        btn.textContent = (emo === null) ? '⭕' : emo;

        const isActive = (emo === null) ? (selected === '') : (selected === emo);
        if (isActive) btn.classList.add('active');

        btn.addEventListener('click', ()=>{
          selected = (emo === null) ? '' : emo;
          localStorage.setItem('cc_emoji', selected);
          try { window.dispatchEvent(new CustomEvent('cc_emoji_changed', { detail: { emoji: selected } })); } catch {}
          updatePreview();
          // active style
          emojiGrid.querySelectorAll('.emoji-btn').forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          if (emojiSetup) emojiSetup.classList.remove('open');
        });

        emojiGrid.appendChild(btn);
      });
    }

    function updatePreview(){
      // DOM-based preview (no canvas): preserves emoji shading + lets CSS filters do the magic
      emojiDisplay.innerHTML = '';
      emojiDisplay.className = 'emoji-layer';

      if (!selected){
        const circle = document.createElement('div');
        circle.className = 'empty-circle';
        emojiDisplay.appendChild(circle);
        emojiDisplay.style.filter = 'none';
        return;
      }

      emojiDisplay.textContent = selected;

      // Compute filter pipeline (sepia+hue-rotate) like cluster rendering
      const hex = gateColor.value || '#00ffd5';
      const rgb = (function(){
        const h = hex.replace('#','');
        const n = parseInt(h.length===3 ? (h[0]+h[0]+h[1]+h[1]+h[2]+h[2]) : h, 16);
        return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
      })();

      const isGray = (rgb.r === rgb.g && rgb.g === rgb.b);

      function hueFromRgb(r,g,b){
        r/=255; g/=255; b/=255;
        const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
        const d=mx-mn;
        if (d===0) return 0;
        let h;
        switch(mx){
          case r: h=((g-b)/d)%6; break;
          case g: h=((b-r)/d)+2; break;
          default: h=((r-g)/d)+4; break;
        }
        h*=60;
        if (h<0) h+=360;
        return h;
      }

      if (isGray){
        // No sepia/hue shift for grayscale: keep real difference between white/gray/black
        // Slight boost so it doesn't drown in same-color bubble
        emojiDisplay.style.filter = 'grayscale(1) brightness(1.08) contrast(1.22)';
      } else {
        const hue = hueFromRgb(rgb.r, rgb.g, rgb.b);
        // sepia base shifts the hue wheel (≈ +60°). Compensate so the picked HEX hue matches the preview.
        const hueAdj = ((hue - 60) % 360 + 360) % 360;
        emojiDisplay.style.filter = `grayscale(1) sepia(1) saturate(1.35) hue-rotate(${hueAdj}deg) brightness(0.95) contrast(1.12)`;
      }
    }
      // Outline + subtle glow (like clusters), so the avatar doesn't drown in same-color bubble.
      function lightenHex(hex, amt){
        const h = (hex||'#00ffd5').replace('#','');
        const n = parseInt(h.length===3 ? (h[0]+h[0]+h[1]+h[1]+h[2]+h[2]) : h, 16);
        let r=(n>>16)&255, g=(n>>8)&255, b=n&255;
        r = Math.min(255, Math.round(r + (255-r)*amt));
        g = Math.min(255, Math.round(g + (255-g)*amt));
        b = Math.min(255, Math.round(b + (255-b)*amt));
        return `rgb(${r}, ${g}, ${b})`;
      }

      if (!selected){
        emojiDisplay.style.textShadow = 'none';
      } else if (isGray){
        // neutral outline, no glow
        emojiDisplay.style.textShadow =
          '0 0 0.8px rgba(0,0,0,0.85), 0 0 2px rgba(0,0,0,0.55)';
      } else {
        const glow = lightenHex(hex, 0.35);
        // fake outline with multi-shadow + soft glow
        emojiDisplay.style.textShadow =
          `0 0 1px ${glow}, 0 0 2px ${glow}, 0 0 8px rgba(0,0,0,0.15),
           -1px 0 ${glow}, 1px 0 ${glow}, 0 -1px ${glow}, 0 1px ${glow},
           -1px -1px ${glow}, 1px -1px ${glow}, -1px 1px ${glow}, 1px 1px ${glow}`;
      }


    // color picker: keep in sync with preview
    function syncColor(){
      updatePreview();
      if (window.__neoApplyAccent) window.__neoApplyAccent(gateColor.value);
    }

gateColor.addEventListener('input', syncColor);
    syncColor();

    renderGrid();
    updatePreview();

    // IMPORTANT: file:// often breaks ES-module imports (Firebase CDN). Give a hint.
    if (location.protocol === 'file:' && gateHint){
      gateHint.textContent = 'Открыто как file://. Так ES-модули (Firebase) часто не грузятся. Запусти через локальный сервер (например VS Code Live Server), иначе кнопка “Войти” может не работать.';
      gateHint.classList.add('show');
    }
  }


  /* ===== Neon / 3D UI helpers (visual only) ===== */
  (function(){
    const root = document.documentElement;

    function hexToRgb(hex){
      if (!hex) return {r:22,g:199,b:183};
      let h = String(hex).trim();
      if (!h) return {r:22,g:199,b:183};
      if (h[0] === '#') h = h.slice(1);
      if (h.length === 3) h = h.split('').map(ch => ch+ch).join('');
      const n = parseInt(h, 16);
      if (!Number.isFinite(n)) return {r:22,g:199,b:183};
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }

    // global: update CSS vars so ALL accents follow account color
    window.__neoApplyAccent = function(colorHex){
      const rgb = hexToRgb(colorHex);
      root.style.setProperty('--acc-r', String(rgb.r));
      root.style.setProperty('--acc-g', String(rgb.g));
      root.style.setProperty('--acc-b', String(rgb.b));

      // keep legacy vars in sync (some old CSS still uses them)
      if (colorHex) root.style.setProperty('--accent', String(colorHex));

      // accent-2 = slightly darker & more saturated
      const dr = Math.max(0, Math.round(rgb.r * 0.78));
      const dg = Math.max(0, Math.round(rgb.g * 0.78));
      const db = Math.max(0, Math.round(rgb.b * 0.78));
      const acc2 = `rgb(${dr}, ${dg}, ${db})`;
      root.style.setProperty('--accent-2', acc2);
    };

    // init accent from saved account color
    try{
      const saved = localStorage.getItem('cc_color') || localStorage.getItem('color') || '#16c7b7';
      window.__neoApplyAccent(saved);
    }catch(e){}

    // magnetic glow ball follows cursor (throttled)
    let raf = 0;
    let lastX = 0, lastY = 0;
    function apply(){
      raf = 0;
      root.style.setProperty('--mx', `${lastX}px`);
      root.style.setProperty('--my', `${lastY}px`);
    }
    function onMove(ev){
      const p = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
      lastX = p.clientX;
      lastY = p.clientY;
      if (!raf) raf = requestAnimationFrame(apply);
    }
    window.addEventListener('pointermove', onMove, {passive:true});
    window.addEventListener('mousemove', onMove, {passive:true});
    window.addEventListener('touchmove', onMove, {passive:true});

    // nice default if no movement yet
    requestAnimationFrame(()=>{ 
      const r = root.getBoundingClientRect();
      lastX = Math.round(r.width * 0.6);
      lastY = Math.round(r.height * 0.25);
      apply();
    });
  })();


  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>

</body>
</html>